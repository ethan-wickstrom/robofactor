# [!SYSTEM] INSTRUCTIONS

## Use & Prefer Functional Programming in All Tasks (UNLESS OTHERWISE SPECIFIED)

You must apply functional programming principles to all tasks unless explicitly instructed otherwise.

### Core Functional Principles

- **First-class functions**: Functions are values that can be assigned, passed as arguments, and returned from other functions
- **Pure functions**: Functions must be deterministic—given the same inputs, always return the same outputs
- **No side effects**: Functions should not alter external state or perform I/O unless explicitly tracked
- **Immutability**: Never modify existing data structures; always create new ones with required changes
- **Declarative style**: Express what should be accomplished, not how to accomplish it step by step
- **Function composition**: Build complex operations by combining simpler functions
- **Prefer recursion over iteration**: Use recursive patterns, but leverage Python's itertools for efficiency

### Program Boundaries and Developer Interfaces

Always create explicit program boundaries. Treat each task as a separate service with a clear interface:

```python
from typing import Protocol
from returns.result import Result
from returns.io import IO

class UserService(Protocol):
    """Clear service boundary with typed interface"""
    def get_user(self, user_id: int) -> IO[Result[User, UserNotFoundError]]: ...
    def create_user(self, data: UserData) -> IO[Result[User, ValidationError]]: ...
```

### Error Handling as Values

Use the type system to track errors and context, not only success values. Side effects are first-class citizens.

```python
from returns.result import Result, Success, Failure
from returns.io import IO, IOResult
from returns.maybe import Maybe

# Type signature shows all possible outcomes
def parse_config(path: str) -> IOResult[Config, ConfigError]:
    """
    Returns:
        IOResult[Config, ConfigError]: Success with Config or Failure with error
    """
    return IO.from_result(
        _read_file(path)
        .bind(_parse_json)
        .bind(_validate_config)
    )
```

### The `returns` Library for Effect Management

Python 3.13 works excellently with the `returns` library for functional effect management:

```python
from returns.result import Result, Success, Failure
from returns.io import IO, IOResult
from returns.maybe import Maybe
from returns.pipeline import flow
from returns.pointfree import bind

# Result type for fallible operations
def divide(a: float, b: float) -> Result[float, str]:
    if b == 0:
        return Failure("Division by zero")
    return Success(a / b)

# IO type for side effects
def read_file(path: str) -> IOResult[str, Exception]:
    @IO
    def _inner() -> Result[str, Exception]:
        try:
            with open(path) as f:
                return Success(f.read())
        except Exception as e:
            return Failure(e)
    return _inner()

# Compose with flow
result = flow(
    user_input,
    parse_number,
    bind(validate_positive),
    bind(calculate_square_root),
)
```

## Python 3.13 Specific Features

### New Type Parameter Syntax (PEP 695)

Python 3.13 introduces cleaner syntax for generics:

```python
# Classes with type parameters
class Stack[T]:
    def __init__(self) -> None:
        self._items: list[T] = []

    def push(self, item: T) -> None:
        self._items.append(item)

    def pop(self) -> T:
        return self._items.pop()

# Functions with type parameters
def first[T](items: Sequence[T]) -> Maybe[T]:
    return Maybe.from_optional(items[0] if items else None)

# Type aliases
type Result[T, E] = Success[T] | Failure[E]
type JsonDict = dict[str, Any]

# With defaults (PEP 696)
class Container[T = str]:
    value: T
```

### Pattern Matching Enhancements

Use pattern matching for cleaner control flow:

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Point:
    x: float
    y: float

def describe_point(point: Point) -> str:
    match point:
        case Point(x=0, y=0):
            return "Origin"
        case Point(x=0, y=y):
            return f"On Y-axis at {y}"
        case Point(x=x, y=0):
            return f"On X-axis at {x}"
        case Point(x=x, y=y) if x == y:
            return f"On diagonal at {x}"
        case Point(x=x, y=y):
            return f"At ({x}, {y})"
```

### Type Narrowing with TypeIs (PEP 742)

```python
from typing import TypeIs

def is_non_empty_list[T](val: list[T]) -> TypeIs[NonEmptyList[T]]:
    """Type guard for non-empty lists"""
    return len(val) > 0

def process_items[T](items: list[T]) -> Maybe[T]:
    if is_non_empty_list(items):
        # items is narrowed to NonEmptyList[T]
        return Some(items[0])
    return Nothing
```

## Type System Best Practices

### Modern Import Patterns (Python 3.13)

```python
# GOOD: Use collections.abc for abstract types
from collections.abc import Sequence, Mapping, Callable, Iterable, Iterator
from types import MappingProxyType  # For immutable dict views

# BAD: Don't use typing module for these
# from typing import Sequence, Mapping  # Deprecated approach

# GOOD: Use returns for Result types
from returns.result import Result
from returns.maybe import Maybe

# BAD: Don't use Optional for nullable values
# from typing import Optional  # Use Maybe instead
```

### Python 3.13 Generic Syntax (PEP 695)

```python
# GOOD: New syntax for generics
class Box[T]:
    def __init__(self, value: T) -> None:
        self._value = value

    def map[U](self, func: Callable[[T], U]) -> Box[U]:
        return Box(func(self._value))

# Function with type parameters
def first[T](items: Sequence[T]) -> Maybe[T]:
    return Maybe.from_optional(items[0] if items else None)

# Type aliases with new syntax
type Result[T, E] = Success[T] | Failure[E]
type ValidationResult[T] = Result[T, ValidationError]

# BAD: Old TypeVar syntax (avoid unless needed for variance)
# from typing import TypeVar, Generic
# T = TypeVar('T')
# class Box(Generic[T]): ...
```

### Type Annotations Guidelines

```python
# Use Final for constants
from typing import Final
MAX_RETRIES: Final = 3

# Use Literal for specific values
from typing import Literal
type Mode = Literal['read', 'write', 'append']

# Use TypedDict for structured data
from typing import TypedDict, Required, NotRequired

class UserData(TypedDict):
    id: Required[int]
    name: Required[str]
    email: NotRequired[str]

# Use Protocol for structural subtyping
from typing import Protocol

class Comparable[T](Protocol):
    def __lt__(self, other: T) -> bool: ...
    def __eq__(self, other: T) -> bool: ...

# Use NewType for semantic distinctions
from typing import NewType
UserId = NewType('UserId', int)
```

### Pattern Matching for Algebraic Data Types

```python
from dataclasses import dataclass
from typing import Final

# Define sum types with dataclasses
@dataclass(frozen=True)
class Success[T]:
    value: T

@dataclass(frozen=True)
class Failure[E]:
    error: E

type Result[T, E] = Success[T] | Failure[E]

# Pattern match on results
def handle_result[T, E](result: Result[T, E]) -> str:
    match result:
        case Success(value):
            return f"Success: {value}"
        case Failure(error):
            return f"Error: {error}"
```

## CLI Design with Typer

```python
import typer
from typing import Annotated
from rich.console import Console
from returns.result import Result

app = typer.Typer()
console = Console()

@app.command()
def process(
    input_file: Annotated[str, typer.Argument(help="Input file path")],
    output: Annotated[str, typer.Option("--output", "-o")] = "output.txt",
    verbose: Annotated[bool, typer.Option("--verbose", "-v")] = False,
) -> None:
    """Process a file with functional transformations."""
    result = (
        read_file(input_file)
        .bind(parse_data)
        .bind(transform_data)
        .bind(lambda data: write_file(output, data))
    )

    match result:
        case Success(_):
            console.print("[green]✓ Processing complete[/green]")
        case Failure(error):
            console.print(f"[red]✗ Error: {error}[/red]")
            raise typer.Exit(code=1)
```

## Functional Data Processing

### Using Itertools and Generators

```python
from itertools import (
    chain, compress, groupby, starmap,
    tee, zip_longest, islice, cycle
)
from collections.abc import Iterator, Iterable
from typing import TypeVar

T = TypeVar('T')

def chunked[T](iterable: Iterable[T], size: int) -> Iterator[tuple[T, ...]]:
    """Split iterable into fixed-size chunks."""
    iterator = iter(iterable)
    while chunk := tuple(islice(iterator, size)):
        yield chunk

def sliding_window[T](iterable: Iterable[T], n: int) -> Iterator[tuple[T, ...]]:
    """Sliding window over iterable."""
    iterators = tee(iterable, n)
    for i, it in enumerate(iterators):
        for _ in range(i):
            next(it, None)
    return zip(*iterators)
```

### Functional Collection Operations

```python
from functools import reduce, partial
from operator import add, mul
from returns.curry import curry

# Curried functions for composition
@curry
def map_over[T, U](func: Callable[[T], U], items: Sequence[T]) -> list[U]:
    return [func(item) for item in items]

@curry
def filter_by[T](predicate: Callable[[T], bool], items: Sequence[T]) -> list[T]:
    return [item for item in items if predicate(item)]

@curry
def reduce_with[T, U](
    func: Callable[[U, T], U],
    initial: U,
    items: Sequence[T]
) -> U:
    return reduce(func, items, initial)

# Compose operations
from returns.pipeline import flow

result = flow(
    data,
    filter_by(lambda x: x > 0),
    map_over(lambda x: x ** 2),
    reduce_with(add, 0),
)
```

## Async Functional Programming

```python
from returns.future import Future, FutureResult
from returns.io import IO
import asyncio

# Async operations as Future values
async def fetch_user(user_id: int) -> Result[User, Exception]:
    try:
        # Async operation
        user = await async_db.get_user(user_id)
        return Success(user)
    except Exception as e:
        return Failure(e)

# Compose async operations
def get_user_posts(user_id: int) -> FutureResult[list[Post], Exception]:
    return (
        FutureResult.from_future(fetch_user(user_id))
        .bind(lambda user: FutureResult.from_future(fetch_posts(user.id)))
    )

# Run with asyncio
async def main() -> None:
    result = await get_user_posts(123)
    match result:
        case Success(posts):
            print(f"Found {len(posts)} posts")
        case Failure(error):
            print(f"Error: {error}")
```

## Testing Functional Code

```python
import pytest
from hypothesis import given, strategies as st
from returns.result import Success, Failure

# Property-based testing
@given(st.integers(), st.integers().filter(lambda x: x != 0))
def test_divide_properties(a: int, b: int) -> None:
    result = divide(a, b)
    assert isinstance(result, Success)
    assert result.unwrap() == a / b

@given(st.integers())
def test_divide_by_zero(a: int) -> None:
    result = divide(a, 0)
    assert isinstance(result, Failure)

# Test pure functions with fixtures
@pytest.fixture
def sample_data() -> list[int]:
    return [1, 2, 3, 4, 5]

def test_transformation_pipeline(sample_data: list[int]) -> None:
    result = flow(
        sample_data,
        filter_by(lambda x: x % 2 == 0),
        map_over(lambda x: x ** 2),
    )
    assert result == [4, 16]
```

## Performance Considerations

```python
from functools import cache, lru_cache
from typing import ParamSpec, TypeVar

P = ParamSpec('P')
R = TypeVar('R')

# Use @cache for pure functions (Python 3.9+)
@cache
def fibonacci(n: int) -> int:
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# LRU cache with size limit
@lru_cache(maxsize=128)
def expensive_computation(x: float, y: float) -> float:
    # Complex calculation
    return complex_math(x, y)

# Generator for memory efficiency
def process_large_file(path: str) -> Iterator[Result[ProcessedLine, Error]]:
    with open(path) as f:
        for line in f:
            yield process_line(line)
```

## Principles

Adhere to these principles to ensure robust, maintainable, and clear system design:

### 1. Apply the IPO Pattern

Break systems into discrete components that accept **Input**, perform **Processing**, and return **Output**.

```python
# Model a web server as Input → Processing → Output
def handle_request(request: Request) -> IO[Response]:
    return flow(
        request,
        validate_request,
        bind(process_business_logic),
        bind(format_response),
    )
```

### 2. All Models Are Wrong, But Some Are Useful

Select models that balance accuracy and simplicity. Validate utility through real-world testing.

### 3. Integrate People as Part of the System

Design interfaces to align with user expectations:

- Mirror established mental models
- Eliminate surprising behaviors
- Prioritize discoverability through consistent patterns

### 4. Principle of Least Astonishment

Ensure interfaces behave predictably:

- Follow Python conventions (e.g., `-h` for help in CLIs)
- Avoid hidden side effects
- Document any deviations from expected behavior

### 5. Fail Fast with Context

```python
@dataclass(frozen=True)
class ValidationError:
    code: str
    field: str
    message: str

def validate_email(email: str) -> Result[str, ValidationError]:
    if "@" not in email:
        return Failure(ValidationError(
            code="INVALID_EMAIL",
            field="email",
            message="Email must contain @"
        ))
    return Success(email)
```

### 6. YAGNI (You Aren't Gonna Need It)

- Postpone features until required
- Delete unused code proactively
- Measure complexity-to-value ratio

### 7. Explicit Dependency Declaration

```python
# Dependencies as typed parameters
def process_order[T](
    order: Order,
    payment_service: PaymentService,
    inventory: InventoryService,
    logger: Logger,
) -> IOResult[Receipt, ProcessError]:
    """All dependencies explicitly declared"""
```

### 8. Type-Driven Design

```python
# Encode business rules in types
@dataclass(frozen=True)
class NonEmptyList[T]:
    head: T
    tail: list[T]

    @classmethod
    def create(cls, items: list[T]) -> Maybe[NonEmptyList[T]]:
        if not items:
            return Nothing
        return Some(cls(items[0], items[1:]))
```

### 9. Design by Contract

```python
def transfer_funds(
    from_account: Account,
    to_account: Account,
    amount: Decimal,
) -> Result[Transaction, TransferError]:
    """
    Preconditions:
        - amount > 0
        - from_account.balance >= amount
        - from_account != to_account

    Postconditions:
        - from_account.balance decreased by amount
        - to_account.balance increased by amount
        - Transaction record created
    """
```

### 10. Single Responsibility & High Cohesion

```python
# Each module has one clear purpose
# user_repository.py - Only data access
class UserRepository:
    def find_by_id(self, id: UserId) -> IOResult[User, NotFoundError]: ...
    def save(self, user: User) -> IOResult[User, SaveError]: ...

# user_validator.py - Only validation
class UserValidator:
    def validate(self, data: UserData) -> Result[ValidatedUser, ValidationError]: ...
```

### 11. Observability by Design

```python
from returns.context import RequiresContext

type Deps = Logger | Metrics

def process_with_telemetry[T](
    data: T,
) -> RequiresContext[IOResult[T, Error], Deps]:
    """Operations with built-in observability"""
```

### 12. Progressive Abstraction

- Start with concrete implementations
- Introduce abstractions only to eliminate duplication
- Refactor when patterns stabilize

### 13. Self-Documenting Code

```python
# Precise naming
def calculate_compound_interest(
    principal: Decimal,
    annual_rate: Decimal,
    years: int,
    compounds_per_year: int = 12,
) -> Decimal:
    """Names explain the computation"""
```

### 14. Principle of Least Power

- Prefer `map()` over manual loops
- Avoid generics until necessary
- Choose simple data structures

### 15. Idempotency by Default

```python
def ensure_user_exists(email: str) -> IOResult[User, Error]:
    """Safe to call multiple times"""
    return (
        find_user_by_email(email)
        .alt(lambda _: create_user(email))
    )
```

### 16. Resource Safety

```python
from contextlib import contextmanager
from returns.context import RequiresContextIOResult

@contextmanager
def database_transaction():
    tx = start_transaction()
    try:
        yield tx
        tx.commit()
    except Exception:
        tx.rollback()
        raise
```

### 17. Version Contracts Semantically

```python
# API versioning
from typing import Literal

API_VERSION: Final = "2.0.0"

type ApiVersion = Literal["1.0", "1.1", "2.0"]

def get_endpoint(version: ApiVersion) -> str:
    return f"/api/v{version}/users"
```

### 18. Mechanical Sympathy

- Profile before optimizing
- Use `__slots__` for memory efficiency
- Prefer cache-friendly data layouts

### 19. Anti-Corruption Layers

```python
# Shield domain from external APIs
@dataclass(frozen=True)
class ExternalUser:
    user_id: str
    full_name: str

@dataclass(frozen=True)
class DomainUser:
    id: UserId
    name: Name

def adapt_external_user(external: ExternalUser) -> Result[DomainUser, AdapterError]:
    """Translate foreign data to internal types"""
```

### 20. Progressive Type Refinement

```python
# Parse → Validate → Use
def process_age(value: str) -> Result[AdultAge, ValidationError]:
    return (
        parse_int(value)
        .bind(validate_positive)
        .bind(ensure_adult)
    )

@dataclass(frozen=True)
class AdultAge:
    value: int

    def __post_init__(self):
        if self.value < 18:
            raise ValueError("Must be adult age")
```

## TypeIs

```python
# TypeIs for type narrowing (PEP 742)
from typing import TypeIs

def is_string_list(val: list[object]) -> TypeIs[list[str]]:
    return all(isinstance(item, str) for item in val)

# Use in type narrowing
def process(items: list[object]) -> str:
    if is_string_list(items):
        # items is narrowed to list[str]
        return ', '.join(items)
    return str(items)
```

## Code Style

Adhere to the following programming philosophy for every code artifact you create or edit:

### Core Principles

- **Always DRY**: Extract shared logic and avoid duplication; every significant behavior should live in exactly one place
- **Always Optimize for Deletion**: Prefer simple, loosely-coupled structures that can be removed without cascading edits
- **Always Stateless by Default**: Treat state as a liability. Functions should carry all required data in parameters and return new data
- **Always Pure Functions Only**: Functions must be deterministic, side-effect-free, and directly testable in isolation
- **Always Swappable Services**: Build services that are identical, swappable, and trivially scalable with no memory between calls
- **Always Place State at the Edge**: Persisted data, caches, and external integrations belong in well-defined boundary layers
- **Always Design for Easy Rewrite**: Assume code might be replaced next week—keep components small, clear, and prediction-free

### Python 3.13 Specific Guidelines

- Always write code in a purely functional style when possible
- Always verify all code is referentially transparent
- Never use type assertions (`cast`) or `# type: ignore`
- Never use `Any` type; use proper generics or protocols
- Always define types using algebraic data types (sum and product types)
- Prefer `@dataclass(frozen=True)` over regular classes
- Use pattern matching for control flow over if/elif chains

## Type System and Imports

### Collections and Generics

- **GOOD**: Use `Sequence[T]` from `collections.abc` for read-only lists
- **BAD**: Never use `list[T]` in function parameters
- **GOOD**: Use `Mapping[K, V]` from `collections.abc` for read-only dicts
- **BAD**: Never use `dict[K, V]` in function parameters
- **GOOD**: Use `frozenset[T]` for immutable sets
- **BAD**: Avoid mutable `set[T]` in APIs

### Modern Generic Syntax (PEP 695)

```python
# GOOD: Python 3.13+ syntax
class Container[T]:
    value: T

def transform[T, U](func: Callable[[T], U], value: T) -> U:
    return func(value)

type Pair[A, B] = tuple[A, B]

# BAD: Old TypeVar syntax
T = TypeVar('T')  # Only use for variance
```

### Result Types and Error Handling

- **GOOD**: Use `Result[T, E]` from returns library
- **BAD**: Never raise exceptions for expected errors
- **GOOD**: Use `Maybe[T]` for nullable values
- **BAD**: Never use `Optional[T]` or raw `None`
- **GOOD**: Use `IO[T]` for side effects
- **BAD**: Never perform I/O in pure functions

## CLI and Command Line Tools

### Typer Best Practices

```python
# GOOD: Use Annotated with defaults
def main(
    name: Annotated[str, typer.Option()] = "World",
    count: Annotated[int, typer.Option()] = 1,
):
    pass

# BAD: Never put defaults in Option()
def main(
    name: str = typer.Option("World"),  # Wrong!
):
    pass
```

- Always use sub-apps for command groups
- Always provide help text for all commands and options
- Use `rich` for enhanced output, never plain `print()`
- Use `typer.Exit(code=n)` instead of `sys.exit()`
- Always validate inputs early in command functions

## Function Design and Composition

### Function Guidelines

- Keep functions under 20 lines
- Single responsibility per function
- Use descriptive names: `calculate_tax_rate()` not `calc()`
- Parameters should be immutable types
- Return new values, never mutate inputs
- Limit parameters to 4 (use parameter objects if needed)
- Always use full type annotations

### Keyword-Only Arguments

```python
# GOOD: Force named arguments for clarity
def create_user(*, name: str, email: str, age: int) -> User:
    pass

# BAD: Positional arguments are ambiguous
def create_user(name: str, email: str, age: int) -> User:
    pass
```

### Function Composition

```python
from returns.pipeline import flow
from returns.pointfree import bind

# GOOD: Compose small functions
result = flow(
    data,
    parse,
    bind(validate),
    bind(transform),
)

# BAD: Monolithic functions
def process_everything(data):
    # 100 lines of mixed concerns
    pass
```

## Data Structures and Immutability

### Immutable Data Classes

```python
# GOOD: Frozen dataclass
@dataclass(frozen=True, slots=True)
class Point:
    x: float
    y: float

    def move(self, dx: float, dy: float) -> Point:
        return Point(self.x + dx, self.y + dy)

# BAD: Mutable class
class Point:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y
```

### Immutable Collections

- Use `tuple` instead of `list` for fixed sequences
- Use `frozenset` instead of `set`
- Use `MappingProxyType` for read-only dict views
- Use `dataclasses.replace()` to create modified copies
- Implement `__slots__` for memory efficiency

### Algebraic Data Types

```python
# Sum types with Union
type Shape = Circle | Rectangle | Triangle

# Product types with dataclasses
@dataclass(frozen=True)
class Circle:
    radius: float

# Pattern matching
match shape:
    case Circle(radius=r):
        return pi * r ** 2
    case Rectangle(width=w, height=h):
        return w * h
```

## Testing and Validation

### Testing Principles

- Write tests first (TDD approach)
- One assertion per test
- Descriptive test names: `test_divide_by_zero_returns_failure`
- Test edge cases: empty, None, boundaries
- Use property-based testing with Hypothesis
- Mock only at boundaries (external services)
- Use fixtures for reusable setup
- Test error conditions explicitly
- Keep tests independent
- Use stubs for queries, mocks for commands

### Property-Based Testing

```python
from hypothesis import given, strategies as st

@given(st.lists(st.integers()))
def test_sort_properties(items: list[int]) -> None:
    sorted_items = sorted(items)
    # Properties that should always hold
    assert len(sorted_items) == len(items)
    assert all(a <= b for a, b in zip(sorted_items, sorted_items[1:]))
    assert set(sorted_items) == set(items)
```

## Performance and Optimization

### Performance Guidelines

- Measure before optimizing (use `cProfile`, `line_profiler`)
- Use generators for large datasets
- Cache with `@cache` or `@lru_cache`
- Use appropriate data structures:
  - `set` for membership tests
  - `deque` for queues
  - `bisect` for sorted operations
- Batch I/O operations
- Use `__slots__` for many instances
- Compile regex once: `PATTERN = re.compile(...)`
- Use NumPy for numerical work

### Memory-Efficient Patterns

```python
# GOOD: Generator for streaming
def read_large_file(path: str) -> Iterator[str]:
    with open(path) as f:
        yield from f

# BAD: Loading everything into memory
def read_large_file(path: str) -> list[str]:
    with open(path) as f:
        return f.readlines()
```

## Async and Concurrency

### Async Patterns

```python
# GOOD: Async for I/O
async def fetch_data(url: str) -> Result[Data, Error]:
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url) as response:
                data = await response.json()
                return Success(Data(**data))
        except Exception as e:
            return Failure(Error(str(e)))

# Use asyncio.gather for parallel operations
results = await asyncio.gather(
    fetch_data(url1),
    fetch_data(url2),
    fetch_data(url3),
)
```

- Prefer asyncio over threading for I/O
- Use semaphores to limit concurrent operations
- Use `asyncio.create_task` for fire-and-forget
- Test async code with `pytest-asyncio`
- Never call blocking functions in async code
- Use `asyncio.Queue` for task distribution

## Documentation and Comments

### Documentation Standards

- Write Google/NumPy style docstrings for public APIs
- Document why, not what
- Keep docs in sync with code
- Use type hints as documentation
- Document raised exceptions
- Provide doctest examples
- Link to references (papers, algorithms)
- Document assumptions and preconditions
- Use meaningful variable names
- Keep README current

### Example Docstring

```python
def calculate_discount(
    price: Decimal,
    discount_percent: Decimal,
) -> Result[Decimal, ValueError]:
    """Calculate discounted price.

    Args:
        price: Original price (must be positive)
        discount_percent: Discount percentage (0-100)

    Returns:
        Result containing discounted price or ValueError

    Examples:
        >>> calculate_discount(Decimal("100"), Decimal("10"))
        Success(Decimal("90"))

    Note:
        Uses banker's rounding for currency calculations.
    """
```

## Security and Safety

- Validate all inputs with whitelisting
- Use parameterized queries (never concatenate SQL)
- Hash passwords with argon2 or bcrypt
- Use environment variables for secrets
- Implement rate limiting
- Log security events with structured logging
- Use HTTPS everywhere
- Validate file uploads (type, size, content)
- Implement CSRF protection
- Keep dependencies updated

## Database and Persistence

- Use Alembic for migrations
- Write idempotent migrations
- Use transactions for consistency
- Implement retry logic with backoff
- Use connection pooling
- Index foreign keys and common queries
- Use EXPLAIN ANALYZE for query optimization
- Implement soft deletes for audit trails
- Use read replicas for scaling
- Automate backups

## API Design

- Use strict consistent REST conventions
- Version APIs: `/api/v1/`, `/api/v2/`
- Use proper HTTP methods and status codes
- Implement pagination with cursors
- Use content negotiation (Accept headers)
- Implement rate limiting
- Document with OpenAPI/Swagger
- Use HATEOAS principles
- Implement idempotency keys
- Return consistent error formats

## Tooling and Development Environment

### Type Checking

```bash
basedpyright --pythonversion 3.13
```

### Development Workflow

1. Write type stubs first
2. Implement with TDD
3. Use property-based testing
4. Profile if needed
5. Document public APIs

## Migration Guide

### From Imperative to Functional

```python
# BAD: Imperative style
def process_users(users):
    result = []
    for user in users:
        if user.active:
            user.score = calculate_score(user)
            result.append(user)
    return result

# GOOD: Functional style
def process_users(users: Sequence[User]) -> list[User]:
    return flow(
        users,
        filter_by(lambda u: u.active),
        map_over(add_score),
    )

def add_score(user: User) -> User:
    return dataclasses.replace(
        user,
        score=calculate_score(user)
    )
```

### From Exceptions to Results

```python
# BAD: Exception-based
def get_user(user_id: int) -> User:
    if not is_valid_id(user_id):
        raise ValueError("Invalid ID")
    user = db.find_user(user_id)
    if not user:
        raise NotFoundError("User not found")
    return user

# GOOD: Result-based
def get_user(user_id: int) -> IOResult[User, GetUserError]:
    return (
        validate_user_id(user_id)
        .bind(lambda vid: find_user_in_db(vid))
    )
```

## Common Patterns

### Railway-Oriented Programming

```python
from returns.pipeline import flow
from returns.pointfree import bind

def process_order(order_data: dict) -> IOResult[Order, ProcessError]:
    return flow(
        order_data,
        validate_order_data,
        bind(check_inventory),
        bind(calculate_pricing),
        bind(reserve_items),
        bind(charge_payment),
        bind(create_order_record),
    )
```

### Dependency Injection with Context

```python
from returns.context import RequiresContext

type AppContext = Database | Logger | Config

def get_user_by_email(
    email: str
) -> RequiresContext[IOResult[User, Error], AppContext]:
    def _inner(ctx: AppContext) -> IOResult[User, Error]:
        return ctx.database.find_user(email=email)
    return RequiresContext(_inner)
```

### Option/Maybe Pattern

```python
from returns.maybe import Maybe, Some, Nothing

def find_first[T](
    predicate: Callable[[T], bool],
    items: Sequence[T],
) -> Maybe[T]:
    for item in items:
        if predicate(item):
            return Some(item)
    return Nothing
```

## Best Practices Summary

1. **Start Pure**: Write pure functions by default, add effects explicitly
2. **Type Everything**: Full type coverage with no `Any` or `cast`
3. **Fail Fast**: Validate at boundaries, return structured errors
4. **Compose Small Functions**: Each function does one thing well
5. **Immutable Data**: Use frozen dataclasses and immutable collections
6. **Track Effects**: Use IO, Result, Maybe to make effects visible
7. **Test Properties**: Use Hypothesis for property-based testing
8. **Document Contracts**: Clear preconditions and postconditions
9. **Version APIs**: Semantic versioning with clear deprecation
10. **Profile When Needed**: Measure before optimizing

## Recommended Libraries

- **returns**: Functional programming primitives (Result, Maybe, IO)
- **pyrsistent**: Persistent/immutable data structures
- **toolz**: Functional utilities and function composition
- **more-itertools**: Additional iteration utilities
- **hypothesis**: Property-based testing
- **attrs**: Alternative to dataclasses with validators
- **cattrs**: Serialization/deserialization for structured data
- **rich**: Enhanced terminal output for CLIs
- **typer**: Modern CLI framework
- **polars**: Functional-style DataFrame operations

## Final Notes

This guide represents best practices for functional programming in Python 3.13. The ecosystem continues to evolve, so:

- Keep dependencies updated
- Follow PEPs for new type system features
- Contribute to typing discussions
- Share patterns that work well

Remember: **Make invalid states unrepresentable, make effects explicit, and keep functions pure.**
