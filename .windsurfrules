# Robofactor Quick-Start

## 1. Write Pure Functions Whenever Possible

- **No side effects** → wrap I/O in `IO[T]` or `IOResult[T, E]`
- **No mutation** → return new values
- **No exceptions** → return `Result[T, E]` or `Maybe[T]`

Push all side effects to CLI entrypoint.

## 2. Type System (PEP 695)

```python
type UserId = int
type Result[T, E] = Success[T] | Failure[E]

@dataclass(frozen=True, slots=True)
class User: ...
```

## 3. Function Rules

- ≤ 20 lines, ≤ 4 params
- Keyword-only after `*`
- Use `flow` to compose:

```python
from returns.pipeline import flow
from returns.pointfree import bind

result = flow(
    data,
    validate,
    bind(process),
    bind(save),
)
```

## 4. CLI (Typer)

```python
def cmd(
    file: Annotated[Path, typer.Argument()],
    out: Annotated[str, typer.Option("-o")] = "out.txt",
) -> None:
    ...
```

- Defaults live in the signature, **not** in `typer.Option`.
- Use `rich` for output, `typer.Exit(code)` to quit.

## 5. Error Handling

```python
def parse_int(s: str) -> Result[int, ValueError]:
    try:
        return Success(int(s))
    except ValueError as e:
        return Failure(e)

match parse_int("42"):
    case Success(n): ...
    case Failure(e): ...
```

## 6. Testing

- **pytest + hypothesis**
- One assertion per test
- Property tests for pure functions

## 7. Tooling

```bash
uv run basedpyright --pythonversion 3.13
uv run ruff check
uv run ruff format
```

## 8. Forbidden

- `Any`, `cast`, `# type: ignore`, `Optional`, `print`, `sys.exit`, mutable globals, `list`/`dict` in signatures.

## 9. Project Skeleton

```bash
src/
  robofactor/  # project source
tests/
  test_*.py    # property tests
pyproject.toml # uv + ruff + basedpyright
```
