"""
This type stub file was generated by pyright.
"""

import mcp
from typing import Any, Callable, Optional, TYPE_CHECKING, Tuple, Type
from pydantic import BaseModel
from dspy.adapters.types.base_type import BaseType
from dspy.utils.callback import with_callbacks
from langchain.tools import BaseTool

if TYPE_CHECKING:
    ...
_TYPE_MAPPING = ...
class Tool(BaseType):
    """Tool class.

    This class is used to simplify the creation of tools for tool calling (function calling) in LLMs. Only supports
    functions for now.
    """
    func: Callable
    name: Optional[str] = ...
    desc: Optional[str] = ...
    args: Optional[dict[str, Any]] = ...
    arg_types: Optional[dict[str, Any]] = ...
    arg_desc: Optional[dict[str, str]] = ...
    has_kwargs: bool = ...
    def __init__(self, func: Callable, name: Optional[str] = ..., desc: Optional[str] = ..., args: Optional[dict[str, Any]] = ..., arg_types: Optional[dict[str, Any]] = ..., arg_desc: Optional[dict[str, str]] = ...) -> None:
        """Initialize the Tool class.

        Users can choose to specify the `name`, `desc`, `args`, and `arg_types`, or let the `dspy.Tool`
        automatically infer the values from the function. For values that are specified by the user, automatic inference
        will not be performed on them.

        Args:
            func (Callable): The actual function that is being wrapped by the tool.
            name (Optional[str], optional): The name of the tool. Defaults to None.
            desc (Optional[str], optional): The description of the tool. Defaults to None.
            args (Optional[dict[str, Any]], optional): The args and their schema of the tool, represented as a
                dictionary from arg name to arg's json schema. Defaults to None.
            arg_types (Optional[dict[str, Any]], optional): The argument types of the tool, represented as a dictionary
                from arg name to the type of the argument. Defaults to None.
            arg_desc (Optional[dict[str, str]], optional): Descriptions for each arg, represented as a
                dictionary from arg name to description string. Defaults to None.

        Example:

        ```python
        def foo(x: int, y: str = "hello"):
            return str(x) + y

        tool = Tool(foo)
        print(tool.args)
        # Expected output: {'x': {'type': 'integer'}, 'y': {'type': 'string', 'default': 'hello'}}
        ```
        """
        ...
    
    def format(self): # -> str:
        ...
    
    def format_as_litellm_function_call(self): # -> dict[str, str | dict[str, str | dict[str, str | dict[str, Any] | list[str] | None] | None]]:
        ...
    
    @with_callbacks
    def __call__(self, **kwargs): # -> Any:
        ...
    
    @with_callbacks
    async def acall(self, **kwargs): # -> Any:
        ...
    
    @classmethod
    def from_mcp_tool(cls, session: mcp.client.session.ClientSession, tool: mcp.types.Tool) -> Tool:
        """
        Build a DSPy tool from an MCP tool and a ClientSession.

        Args:
            session: The MCP session to use.
            tool: The MCP tool to convert.

        Returns:
            A Tool object.
        """
        ...
    
    @classmethod
    def from_langchain(cls, tool: BaseTool) -> Tool:
        """
        Build a DSPy tool from a LangChain tool.

        Args:
            tool: The LangChain tool to convert.

        Returns:
            A Tool object.

        Example:

        ```python
        import asyncio
        import dspy
        from langchain.tools import tool as lc_tool

        @lc_tool
        def add(x: int, y: int):
            "Add two numbers together."
            return x + y

        dspy_tool = dspy.Tool.from_langchain(add)

        async def run_tool():
            return await dspy_tool.acall(x=1, y=2)

        print(asyncio.run(run_tool()))
        # 3
        ```
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class ToolCalls(BaseType):
    class ToolCall(BaseModel):
        name: str
        args: dict[str, Any]
        ...
    
    
    tool_calls: list[ToolCall]
    @classmethod
    def from_dict_list(cls, tool_calls_dicts: list[dict[str, Any]]) -> ToolCalls:
        """Convert a list of dictionaries to a ToolCalls instance.

        Args:
            dict_list: A list of dictionaries, where each dictionary should have 'name' and 'args' keys.

        Returns:
            A ToolCalls instance.

        Example:

            ```python
            tool_calls_dict = [
                {"name": "search", "args": {"query": "hello"}},
                {"name": "translate", "args": {"text": "world"}}
            ]
            tool_calls = ToolCalls.from_dict_list(tool_calls_dict)
            ```
        """
        ...
    
    @classmethod
    def description(cls) -> str:
        ...
    


def convert_input_schema_to_tool_args(schema: dict[str, Any]) -> Tuple[dict[str, Any], dict[str, Type], dict[str, str]]:
    """Convert an input json schema to tool arguments compatible with DSPy Tool.

    Args:
        schema: An input json schema describing the tool's input parameters

    Returns:
        A tuple of (args, arg_types, arg_desc) for DSPy Tool definition.
    """
    ...

