"""
This type stub file was generated by pyright.
"""

import dspy
from typing import Callable

logger = ...

def prepare_models_for_resampling(program: dspy.Module, n: int):  # -> list[LM | Any]:
    ...
def wrap_program(
    program: dspy.Module, metric: Callable
):  # -> Callable[..., dict[str, Any | float | None]]:
    ...
def append_a_demo(demo_input_field_maxlen):  # -> Callable[..., Literal[True]]:
    ...
def append_a_rule(bucket, system, **kwargs):  # -> bool:
    ...

class OfferFeedback(dspy.Signature):
    """
    You will be given two trajectories of an LLM-driven program's execution. Your goal is to help the program's modules
    build up experience on how to maximize the reward value assigned to the program's outputs if it were to receive
    similar inputs in the future.

    The module won't see its own history. It will rely on your advice balancing being concrete and being generalizable.

    In your advice:
    - Avoid boilerplate. Offer advice that would change the module's behavior for the better in the future.
    - Ensure that advice offered to a module M is specific to that M's specific sub-task, not the overall program.
    - Rely on contrasting the behavior of the worse trajectory against the better trajectory in making recommendations.
    - Ensure each unique module name appears exactly once as a key in the advice dictionary.
    """

    program_code: str = ...
    modules_defn: str = ...
    program_inputs: str = ...
    oracle_metadata: str = ...
    worse_program_trajectory: str = ...
    worse_program_outputs: str = ...
    worse_reward_value: float = ...
    better_program_trajectory: str = ...
    better_program_outputs: str = ...
    better_reward_value: float = ...
    module_names: list[str] = ...
    discussion: str = ...
    module_advice: dict[str, str] = ...

def inspect_modules(program):  # -> str:
    ...
def recursive_mask(
    o,
):  # -> dict[Any, Any | dict[Any, Any] | list[Any | dict[Any, Any] | list[Any] | tuple[Any, ...] | str] | tuple[Any, ...] | str] | list[Any | dict[Any, Any | dict[Any, Any] | list[Any] | tuple[Any, ...] | str] | list[Any] | tuple[Any, ...] | str] | tuple[Any, ...] | str:
    ...
