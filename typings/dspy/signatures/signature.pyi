"""
This type stub file was generated by pyright.
"""

from typing import Dict, Optional, Tuple, Type, Union
from pydantic import BaseModel
from pydantic.fields import FieldInfo

"""Signature class for DSPy.

You typically subclass the Signature class, like this:
    class MySignature(dspy.Signature):
        input: str = InputField(desc="...")
        output: int = OutputField(desc="...")

You can call Signature("input1, input2 -> output1, output2") to create a new signature type.
You can also include instructions, Signature("input -> output", "This is a test").
But it's generally better to use the make_signature function.

If you are not sure if your input is a string representation, (like "input1, input2 -> output1, output2"),
or a signature, you can use the ensure_signature function.

For compatibility with the legacy dsp format, you can use the signature_to_template function.
"""

class SignatureMeta(type(BaseModel)):
    def __call__(cls, *args, **kwargs):  # -> type[Signature] | Any:
        ...
    def __new__(mcs, signature_name, bases, namespace, **kwargs):  # -> type:
        ...
    @property
    def instructions(cls) -> str: ...
    @instructions.setter
    def instructions(cls, instructions: str) -> None: ...
    @property
    def input_fields(cls) -> dict[str, FieldInfo]: ...
    @property
    def output_fields(cls) -> dict[str, FieldInfo]: ...
    @property
    def fields(cls) -> dict[str, FieldInfo]: ...
    @property
    def signature(cls) -> str:
        """The string representation of the signature."""
        ...

    def __repr__(cls):  # -> str:
        """Output a representation of the signature.

        Uses the form:
        Signature(question, context -> answer
            question: str = InputField(desc="..."),
            context: List[str] = InputField(desc="..."),
            answer: int = OutputField(desc="..."),
        ).
        """
        ...

class Signature(BaseModel, metaclass=SignatureMeta):
    ""
    @classmethod
    def with_instructions(cls, instructions: str) -> Type[Signature]: ...
    @classmethod
    def with_updated_fields(cls, name, type_=..., **kwargs) -> Type[Signature]:
        """Create a new Signature class with the updated field information.

        Returns a new Signature class with the field, name, updated
        with fields[name].json_schema_extra[key] = value.

        Args:
            name: The name of the field to update.
            type_: The new type of the field.
            **kwargs: The new values for the field.

        Returns:
            A new Signature class (not an instance) with the updated field information.
        """
        ...

    @classmethod
    def prepend(cls, name, field, type_=...) -> Type[Signature]: ...
    @classmethod
    def append(cls, name, field, type_=...) -> Type[Signature]: ...
    @classmethod
    def delete(cls, name) -> Type[Signature]: ...
    @classmethod
    def insert(
        cls, index: int, name: str, field, type_: Optional[Type] = ...
    ) -> Type[Signature]: ...
    @classmethod
    def equals(cls, other) -> bool:
        """Compare the JSON schema of two Signature classes."""
        ...

    @classmethod
    def dump_state(cls):  # -> dict[str, str | list[Any]]:
        ...
    @classmethod
    def load_state(cls, state):  # -> Signature:
        ...

def ensure_signature(signature: Union[str, Type[Signature]], instructions=...) -> Signature: ...
def make_signature(
    signature: Union[str, Dict[str, Tuple[type, FieldInfo]]],
    instructions: Optional[str] = ...,
    signature_name: str = ...,
    custom_types: Optional[Dict[str, Type]] = ...,
) -> Type[Signature]:
    """Create a new Signature subclass with the specified fields and instructions.

    Args:
        signature: Either a string in the format "input1, input2 -> output1, output2"
            or a dictionary mapping field names to tuples of (type, FieldInfo).
        instructions: Optional string containing instructions/prompt for the signature.
            If not provided, defaults to a basic description of inputs and outputs.
        signature_name: Optional string to name the generated Signature subclass.
            Defaults to "StringSignature".
        custom_types: Optional dictionary mapping type names to their actual type objects.
            Useful for resolving custom types that aren't built-ins or in the typing module.

    Returns:
        A new signature class with the specified fields and instructions.

    Examples:

    ```
    # Using string format
    sig1 = make_signature("question, context -> answer")

    # Using dictionary format
    sig2 = make_signature({
        "question": (str, InputField()),
        "answer": (str, OutputField())
    })

    # Using custom types
    class MyType:
        pass

    sig3 = make_signature("input: MyType -> output", custom_types={"MyType": MyType})
    ```
    """
    ...

def infer_prefix(attribute_name: str) -> str:
    """Infer a prefix from an attribute name by converting it to a human-readable format.

    Examples:
        "camelCaseText" -> "Camel Case Text"
        "snake_case_text" -> "Snake Case Text"
        "text2number" -> "Text 2 Number"
        "HTMLParser" -> "HTML Parser"
    """
    ...
