{"spans": [{"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "W0x8leNJu4o=", "trace_state": "", "parent_span_id": "", "name": "Refine.forward", "start_time_unix_nano": 1750223950523753000, "end_time_unix_nano": 1750224147930239000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\", \"refactoring_opportunities\": [\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\", \"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\", \"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\", \"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\", \"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\"], \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\", \"plan_steps\": [\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\", \"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\", \"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\", \"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\", \"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\", \"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\", \"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\"], \"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\"}", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}", "mlflow.spanType": "\"CHAIN\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "tqR6SZmNM7E=", "trace_state": "", "parent_span_id": "W0x8leNJu4o=", "name": "CodeRefactor.forward", "start_time_unix_nano": 1750223950524302000, "end_time_unix_nano": 1750224130956653000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\", \"refactoring_opportunities\": [\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\", \"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\", \"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\", \"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\", \"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\"], \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\", \"plan_steps\": [\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\", \"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\", \"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\", \"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\", \"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\", \"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\", \"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\"], \"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\"}", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}", "mlflow.spanType": "\"CHAIN\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "HMYU+xvx8WE=", "trace_state": "", "parent_span_id": "tqR6SZmNM7E=", "name": "Predict.forward_1", "start_time_unix_nano": 1750223950524470000, "end_time_unix_nano": 1750223979308753000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\", \"refactoring_opportunities\": [\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\", \"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\", \"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\", \"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\", \"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\"]}", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}", "mlflow.spanType": "\"LLM\"", "signature": "\"code_snippet -> analysis, refactoring_opportunities\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "NpkYsxjb2t0=", "trace_state": "", "parent_span_id": "HMYU+xvx8WE=", "name": "ChatAdapter.format_1", "start_time_unix_nano": 1750223950524622000, "end_time_unix_nano": 1750223950526134000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The Python code to be analyzed.\\nYour output fields are:\\n1. `analysis` (str): A concise summary of the code's functionality and complexity.\\n2. `refactoring_opportunities` (list[str]): A bulleted list of specific, actionable refactoring opportunities.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_opportunities ## ]]\\n{refactoring_opportunities}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\n        \\n        For the provided code snippet:\\n        - Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\n        - Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\n        \\n        Ensure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The summation of `res` can be done more concisely using the built-in `sum()` function.\\\", \\\"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\\\", \\\"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## analysis ## ]]`, then `[[ ## refactoring_opportunities ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet -> analysis, refactoring_opportunities\\n    instructions=\\\"You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\\\n\\\\nFor the provided code snippet:\\\\n- Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\\\n- Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\\\n\\\\nEnsure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The Python code to be analyzed.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': \\\"A concise summary of the code's functionality and complexity.\\\", '__dspy_field_type': 'output', 'prefix': 'Analysis:'})\\n    refactoring_opportunities = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A bulleted list of specific, actionable refactoring opportunities.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Opportunities:'})\\n)\", \"demos\": [{\"augmented\": true, \"code_snippet\": \"\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\", \"analysis\": \"The Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\", \"refactoring_opportunities\": [\"The summation of `res` can be done more concisely using the built-in `sum()` function.\", \"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\", \"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\"]}], \"inputs\": {\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "SJDLLqY6Rt4=", "trace_state": "", "parent_span_id": "HMYU+xvx8WE=", "name": "LM.__call___1", "start_time_unix_nano": 1750223950526214000, "end_time_unix_nano": 1750223979307347000, "attributes": {"mlflow.spanOutputs": "[\"[[ ## analysis ## ]]\\nThe code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\\\", \\\"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\\\", \\\"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\\\", \\\"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\\\", \\\"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\\\"]\\n\\n[[ ## completed ## ]]\"]", "temperature": "0.0", "cache": "true", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The Python code to be analyzed.\\nYour output fields are:\\n1. `analysis` (str): A concise summary of the code's functionality and complexity.\\n2. `refactoring_opportunities` (list[str]): A bulleted list of specific, actionable refactoring opportunities.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_opportunities ## ]]\\n{refactoring_opportunities}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\n        \\n        For the provided code snippet:\\n        - Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\n        - Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\n        \\n        Ensure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The summation of `res` can be done more concisely using the built-in `sum()` function.\\\", \\\"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\\\", \\\"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## analysis ## ]]`, then `[[ ## refactoring_opportunities ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The Python code to be analyzed.\\nYour output fields are:\\n1. `analysis` (str): A concise summary of the code's functionality and complexity.\\n2. `refactoring_opportunities` (list[str]): A bulleted list of specific, actionable refactoring opportunities.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_opportunities ## ]]\\n{refactoring_opportunities}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\n        \\n        For the provided code snippet:\\n        - Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\n        - Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\n        \\n        Ensure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The summation of `res` can be done more concisely using the built-in `sum()` function.\\\", \\\"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\\\", \\\"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## analysis ## ]]`, then `[[ ## refactoring_opportunities ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\\\", \\\"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\\\", \\\"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\\\", \\\"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\\\", \\\"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\\\"]\\n\\n[[ ## completed ## ]]\"}]", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\"", "max_tokens": "64000", "model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "mlflow.spanType": "\"CHAT_MODEL\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "geHDXc2Gyd0=", "trace_state": "", "parent_span_id": "HMYU+xvx8WE=", "name": "ChatAdapter.parse_1", "start_time_unix_nano": 1750223979307667000, "end_time_unix_nano": 1750223979308624000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\", \"refactoring_opportunities\": [\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\", \"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\", \"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\", \"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\", \"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\"]}", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet -> analysis, refactoring_opportunities\\n    instructions=\\\"You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\\\n\\\\nFor the provided code snippet:\\\\n- Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\\\n- Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\\\n\\\\nEnsure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The Python code to be analyzed.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': \\\"A concise summary of the code's functionality and complexity.\\\", '__dspy_field_type': 'output', 'prefix': 'Analysis:'})\\n    refactoring_opportunities = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A bulleted list of specific, actionable refactoring opportunities.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Opportunities:'})\\n)\", \"completion\": \"[[ ## analysis ## ]]\\nThe code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.\\\", \\\"Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.\\\", \\\"In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.\\\", \\\"The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.\\\", \\\"The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.\\\"]\\n\\n[[ ## completed ## ]]\"}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "0tSZhKES5FA=", "trace_state": "", "parent_span_id": "tqR6SZmNM7E=", "name": "Predict.forward_2", "start_time_unix_nano": 1750223979308893000, "end_time_unix_nano": 1750224025895481000, "attributes": {"mlflow.spanOutputs": "{\"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\", \"plan_steps\": [\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\", \"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\", \"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\", \"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\", \"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\", \"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\", \"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\"]}", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"analysis\": \"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\"}", "mlflow.spanType": "\"LLM\"", "signature": "\"code_snippet, analysis -> refactoring_summary, plan_steps\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "L+8i29/k4Iw=", "trace_state": "", "parent_span_id": "0tSZhKES5FA=", "name": "ChatAdapter.format_2", "start_time_unix_nano": 1750223979309171000, "end_time_unix_nano": 1750223979310547000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The original Python code snippet.\\n2. `analysis` (str): The analysis of the code snippet.\\nYour output fields are:\\n1. `refactoring_summary` (str): A high-level summary of the refactoring goal.\\n2. `plan_steps` (list[str]): A detailed, step-by-step list of actions to refactor the code.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\n        \\n        1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\n        \\n        2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\n        \\n        Ensure your response is structured as follows:\\n        - **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\n        - **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\n        \\n        Base your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## analysis ## ]]\\nThe code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactoring_summary ## ]]`, then `[[ ## plan_steps ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet, analysis -> refactoring_summary, plan_steps\\n    instructions=\\\"You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\\\n\\\\n1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\\\n\\\\n2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\\\n\\\\nEnsure your response is structured as follows:\\\\n- **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\\\n- **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\\\n\\\\nBase your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The original Python code snippet.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': 'The analysis of the code snippet.', '__dspy_field_type': 'input', 'prefix': 'Analysis:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'A high-level summary of the refactoring goal.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A detailed, step-by-step list of actions to refactor the code.', '__dspy_field_type': 'output', 'prefix': 'Plan Steps:'})\\n)\", \"demos\": [{\"augmented\": true, \"code_snippet\": \"\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\", \"analysis\": \"The Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\", \"refactoring_summary\": \"Simplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\", \"plan_steps\": [\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\", \"Remove the intermediate `total` variable.\", \"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\", \"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\"]}], \"inputs\": {\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"analysis\": \"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\"}}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "wcsYewT1fes=", "trace_state": "", "parent_span_id": "0tSZhKES5FA=", "name": "LM.__call___2", "start_time_unix_nano": 1750223979310658000, "end_time_unix_nano": 1750224025893809000, "attributes": {"mlflow.spanOutputs": "[\"[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\\\", \\\"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\\\", \\\"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\\\", \\\"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\\\", \\\"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\\\", \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", \\\"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\\\"]\\n\\n[[ ## completed ## ]]\"]", "temperature": "0.0", "cache": "true", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The original Python code snippet.\\n2. `analysis` (str): The analysis of the code snippet.\\nYour output fields are:\\n1. `refactoring_summary` (str): A high-level summary of the refactoring goal.\\n2. `plan_steps` (list[str]): A detailed, step-by-step list of actions to refactor the code.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\n        \\n        1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\n        \\n        2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\n        \\n        Ensure your response is structured as follows:\\n        - **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\n        - **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\n        \\n        Base your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## analysis ## ]]\\nThe code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactoring_summary ## ]]`, then `[[ ## plan_steps ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The original Python code snippet.\\n2. `analysis` (str): The analysis of the code snippet.\\nYour output fields are:\\n1. `refactoring_summary` (str): A high-level summary of the refactoring goal.\\n2. `plan_steps` (list[str]): A detailed, step-by-step list of actions to refactor the code.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\n        \\n        1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\n        \\n        2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\n        \\n        Ensure your response is structured as follows:\\n        - **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\n        - **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\n        \\n        Base your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## analysis ## ]]\\nThe code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactoring_summary ## ]]`, then `[[ ## plan_steps ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\\\", \\\"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\\\", \\\"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\\\", \\\"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\\\", \\\"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\\\", \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", \\\"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\\\"]\\n\\n[[ ## completed ## ]]\"}]", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\"", "max_tokens": "64000", "model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "mlflow.spanType": "\"CHAT_MODEL\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "7McjruncWiY=", "trace_state": "", "parent_span_id": "0tSZhKES5FA=", "name": "ChatAdapter.parse_2", "start_time_unix_nano": 1750224025894186000, "end_time_unix_nano": 1750224025895360000, "attributes": {"mlflow.spanOutputs": "{\"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\", \"plan_steps\": [\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\", \"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\", \"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\", \"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\", \"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\", \"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\", \"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\"]}", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet, analysis -> refactoring_summary, plan_steps\\n    instructions=\\\"You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\\\n\\\\n1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\\\n\\\\n2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\\\n\\\\nEnsure your response is structured as follows:\\\\n- **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\\\n- **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\\\n\\\\nBase your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The original Python code snippet.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': 'The analysis of the code snippet.', '__dspy_field_type': 'input', 'prefix': 'Analysis:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'A high-level summary of the refactoring goal.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A detailed, step-by-step list of actions to refactor the code.', '__dspy_field_type': 'output', 'prefix': 'Plan Steps:'})\\n)\", \"completion\": \"[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\\\", \\\"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\\\", \\\"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\\\", \\\"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\\\", \\\"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\\\", \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", \\\"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\\\"]\\n\\n[[ ## completed ## ]]\"}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "Prd745oLB3g=", "trace_state": "", "parent_span_id": "tqR6SZmNM7E=", "name": "Predict.forward_3", "start_time_unix_nano": 1750224025895652000, "end_time_unix_nano": 1750224130956393000, "attributes": {"mlflow.spanOutputs": "{\"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\"}", "mlflow.spanInputs": "{\"original_code\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\", \"plan_steps\": [\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\", \"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\", \"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\", \"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\", \"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\", \"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\", \"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\"]}", "mlflow.spanType": "\"LLM\"", "signature": "\"original_code, refactoring_summary, plan_steps -> refactored_code, implementation_explanation\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "OeNq74FmZpI=", "trace_state": "", "parent_span_id": "Prd745oLB3g=", "name": "ChatAdapter.format_3", "start_time_unix_nano": 1750224025895963000, "end_time_unix_nano": 1750224025897398000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `original_code` (str): The original, un-refactored Python code.\\n2. `refactoring_summary` (str): The high-level goal of the refactoring.\\n3. `plan_steps` (list[str]): The step-by-step plan to apply.\\nYour output fields are:\\n1. `refactored_code` (str): The final, PEP8-compliant, refactored Python code block with type hints and docstrings.\\n2. `implementation_explanation` (str): A brief explanation of how the plan was implemented.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## original_code ## ]]\\n{original_code}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}\\n\\n[[ ## refactored_code ## ]]\\n{refactored_code}\\n\\n[[ ## implementation_explanation ## ]]\\n{implementation_explanation}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\n        \\n        Inputs:\\n        - Original Code: The initial Python code snippet that needs refactoring.\\n        - Refactoring Summary: A high-level overview of the refactoring goals.\\n        - Plan Steps: A list of specific, step-by-step actions to apply.\\n        \\n        Outputs:\\n        - Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\n.\\n        - Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\n        \\n        Be precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\\\", \\\"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\\\", \\\"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\\\", \\\"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\\\", \\\"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\\\", \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", \\\"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\\\"]\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactored_code ## ]]`, then `[[ ## implementation_explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.spanInputs": "{\"signature\": \"StringSignature(original_code, refactoring_summary, plan_steps -> refactored_code, implementation_explanation\\n    instructions=\\\"You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\\\n\\\\nInputs:\\\\n- Original Code: The initial Python code snippet that needs refactoring.\\\\n- Refactoring Summary: A high-level overview of the refactoring goals.\\\\n- Plan Steps: A list of specific, step-by-step actions to apply.\\\\n\\\\nOutputs:\\\\n- Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\\\\\n.\\\\n- Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\\\n\\\\nBe precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\\\"\\n    original_code = Field(annotation=str required=True json_schema_extra={'desc': 'The original, un-refactored Python code.', '__dspy_field_type': 'input', 'prefix': 'Original Code:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'The high-level goal of the refactoring.', '__dspy_field_type': 'input', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'The step-by-step plan to apply.', '__dspy_field_type': 'input', 'prefix': 'Plan Steps:'})\\n    refactored_code = Field(annotation=str required=True json_schema_extra={'prefix': '```python\\\\n', 'desc': 'The final, PEP8-compliant, refactored Python code block with type hints and docstrings.', '__dspy_field_type': 'output'})\\n    implementation_explanation = Field(annotation=str required=True json_schema_extra={'desc': 'A brief explanation of how the plan was implemented.', '__dspy_field_type': 'output', 'prefix': 'Implementation Explanation:'})\\n)\", \"demos\": [{\"augmented\": true, \"original_code\": \"\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\", \"refactoring_summary\": \"Simplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\", \"plan_steps\": [\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\", \"Remove the intermediate `total` variable.\", \"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\", \"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\"], \"refactored_code\": \"```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\", \"implementation_explanation\": \"The refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}], \"inputs\": {\"original_code\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\", \"plan_steps\": [\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\", \"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\", \"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\", \"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\", \"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\", \"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\", \"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\"]}}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "yCTzvFeQIGU=", "trace_state": "", "parent_span_id": "Prd745oLB3g=", "name": "LM.__call___3", "start_time_unix_nano": 1750224025897522000, "end_time_unix_nano": 1750224130954426000, "attributes": {"mlflow.spanOutputs": "[\"[[ ## refactored_code ## ]]\\n```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\\n\\n[[ ## completed ## ]]\"]", "temperature": "0.0", "cache": "true", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `original_code` (str): The original, un-refactored Python code.\\n2. `refactoring_summary` (str): The high-level goal of the refactoring.\\n3. `plan_steps` (list[str]): The step-by-step plan to apply.\\nYour output fields are:\\n1. `refactored_code` (str): The final, PEP8-compliant, refactored Python code block with type hints and docstrings.\\n2. `implementation_explanation` (str): A brief explanation of how the plan was implemented.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## original_code ## ]]\\n{original_code}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}\\n\\n[[ ## refactored_code ## ]]\\n{refactored_code}\\n\\n[[ ## implementation_explanation ## ]]\\n{implementation_explanation}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\n        \\n        Inputs:\\n        - Original Code: The initial Python code snippet that needs refactoring.\\n        - Refactoring Summary: A high-level overview of the refactoring goals.\\n        - Plan Steps: A list of specific, step-by-step actions to apply.\\n        \\n        Outputs:\\n        - Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\n.\\n        - Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\n        \\n        Be precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\\\", \\\"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\\\", \\\"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\\\", \\\"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\\\", \\\"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\\\", \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", \\\"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\\\"]\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactored_code ## ]]`, then `[[ ## implementation_explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `original_code` (str): The original, un-refactored Python code.\\n2. `refactoring_summary` (str): The high-level goal of the refactoring.\\n3. `plan_steps` (list[str]): The step-by-step plan to apply.\\nYour output fields are:\\n1. `refactored_code` (str): The final, PEP8-compliant, refactored Python code block with type hints and docstrings.\\n2. `implementation_explanation` (str): A brief explanation of how the plan was implemented.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## original_code ## ]]\\n{original_code}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}\\n\\n[[ ## refactored_code ## ]]\\n{refactored_code}\\n\\n[[ ## implementation_explanation ## ]]\\n{implementation_explanation}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\n        \\n        Inputs:\\n        - Original Code: The initial Python code snippet that needs refactoring.\\n        - Refactoring Summary: A high-level overview of the refactoring goals.\\n        - Plan Steps: A list of specific, step-by-step actions to apply.\\n        \\n        Outputs:\\n        - Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\n.\\n        - Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\n        \\n        Be precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.\\\", \\\"Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.\\\", \\\"Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.\\\", \\\"In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.\\\", \\\"Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.\\\", \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", \\\"Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.\\\"]\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactored_code ## ]]`, then `[[ ## implementation_explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\\n\\n[[ ## completed ## ]]\"}]", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\"", "max_tokens": "64000", "model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "mlflow.spanType": "\"CHAT_MODEL\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "oCk3AjtgEk4=", "trace_state": "", "parent_span_id": "Prd745oLB3g=", "name": "ChatAdapter.parse_3", "start_time_unix_nano": 1750224130954730000, "end_time_unix_nano": 1750224130956145000, "attributes": {"mlflow.spanOutputs": "{\"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\"}", "mlflow.spanInputs": "{\"signature\": \"StringSignature(original_code, refactoring_summary, plan_steps -> refactored_code, implementation_explanation\\n    instructions=\\\"You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\\\n\\\\nInputs:\\\\n- Original Code: The initial Python code snippet that needs refactoring.\\\\n- Refactoring Summary: A high-level overview of the refactoring goals.\\\\n- Plan Steps: A list of specific, step-by-step actions to apply.\\\\n\\\\nOutputs:\\\\n- Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\\\\\n.\\\\n- Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\\\n\\\\nBe precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\\\"\\n    original_code = Field(annotation=str required=True json_schema_extra={'desc': 'The original, un-refactored Python code.', '__dspy_field_type': 'input', 'prefix': 'Original Code:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'The high-level goal of the refactoring.', '__dspy_field_type': 'input', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'The step-by-step plan to apply.', '__dspy_field_type': 'input', 'prefix': 'Plan Steps:'})\\n    refactored_code = Field(annotation=str required=True json_schema_extra={'prefix': '```python\\\\n', 'desc': 'The final, PEP8-compliant, refactored Python code block with type hints and docstrings.', '__dspy_field_type': 'output'})\\n    implementation_explanation = Field(annotation=str required=True json_schema_extra={'desc': 'A brief explanation of how the plan was implemented.', '__dspy_field_type': 'output', 'prefix': 'Implementation Explanation:'})\\n)\", \"completion\": \"[[ ## refactored_code ## ]]\\n```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was executed according to the plan to improve code organization and reduce complexity.\\n\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\n\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\n\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\n\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\n\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\n\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\\n\\n[[ ## completed ## ]]\"}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "VLt6SmiX6cQ=", "trace_state": "", "parent_span_id": "W0x8leNJu4o=", "name": "RefactoringEvaluator.forward", "start_time_unix_nano": 1750224130956828000, "end_time_unix_nano": 1750224147929880000, "attributes": {"mlflow.spanOutputs": "0.94", "mlflow.spanInputs": "{\"args\": [{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}, \"Prediction(\\n    analysis=\\\"The code provides a sophisticated toolkit for static analysis of Python source code using the `ast` module. It parses Python files or source strings into an Abstract Syntax Tree (AST) and traverses it to extract detailed metadata about every function, including its name, signature, parameters, decorators, context (module, class, or nested), and docstring. The functionality is encapsulated in well-structured `dataclass` objects, and the API uses iterators for memory-efficient processing. The complexity is moderate-to-high, requiring a deep understanding of Python's AST structure and function signature rules. The code is well-documented and type-hinted, demonstrating strong design patterns for such a tool.\\\",\\n    refactoring_opportunities=['Refactor the `extract_parameters` function to reduce its length and code duplication. The logic for extracting annotations and default values is repeated for each parameter kind and could be consolidated into a helper function.', 'Introduce a type alias for `Union[ast.FunctionDef, ast.AsyncFunctionDef]` (e.g., `AnyFunctionDef = ...`) to simplify type hints in function signatures like `extract_parameters` and `extract_docstring`, improving readability.', 'In `ast_node_to_source`, replace the broad `except Exception:` with a more specific exception type to avoid catching and masking unrelated errors during the `ast.unparse` operation.', 'The `format_function_signature` function can be simplified. Instead of creating multiple lists for different parameter kinds, a single pass over the `func.parameters` list could build the signature string more linearly and clearly.', 'The `match` statement in `extract_decorators` can be made more concise. The two `ast.Call` cases can be combined into a single case using an `|` (OR) pattern, as their logic is nearly identical.'],\\n    refactoring_summary='The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by reducing code duplication and complexity, particularly in the `extract_parameters` function, by centralizing default value mapping into a dedicated helper. Additionally, the responsibility for creating `FunctionInfo` objects will be moved from the AST visitor to a factory class method on the `FunctionInfo` dataclass itself, improving code organization and cohesion. The `extract_decorators` function will also be simplified by consolidating redundant pattern matching cases.',\\n    plan_steps=['Simplify the `match` statement in `extract_decorators` by merging the two `ast.Call` patterns into a single, more general case that handles any callable expression.', 'Create a new internal helper function, `_map_parameter_defaults(args: ast.arguments) -> dict[str, str]`, to encapsulate the logic for mapping parameter names to their default value source strings. This function will handle both positional and keyword-only defaults, removing complex index calculations from `extract_parameters`.', 'Refactor `extract_parameters` to use the new `_map_parameter_defaults` helper. Replace the manual default value lookups with a simple dictionary `get()` call for each parameter.', 'In `extract_parameters`, consolidate the creation of `Parameter` objects for variadic arguments (`*args`, `**kwargs`) into a loop to reduce code repetition.', 'Create a new class method `FunctionInfo.from_ast_node(cls, node, context)` and move the object instantiation logic from `_FunctionVisitor._visit_function_def` into it. This makes `FunctionInfo` responsible for its own creation from an AST node.', \\\"Update `_FunctionVisitor._visit_function_def` to call the new `FunctionInfo.from_ast_node` factory method, simplifying the visitor's logic.\\\", 'Add clear docstrings and precise type hints for the new helper function and class method created during the refactoring.'],\\n    refactored_code='```python\\\\nimport ast\\\\nimport enum\\\\nfrom dataclasses import dataclass\\\\nfrom pathlib import Path\\\\nfrom typing import Iterator, Type, Union\\\\n\\\\n\\\\nclass ParameterKind(enum.Enum):\\\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass Parameter:\\\\n    \\\"\\\"\\\"\\\\n    Represents a function parameter with its name, kind, and optional details.\\\\n\\\\n    Attributes:\\\\n        name: The name of the parameter.\\\\n        kind: The kind of the parameter (e.g., positional-only).\\\\n        annotation: The type annotation as a string, if present.\\\\n        default: The default value as a string, if present.\\\\n    \\\"\\\"\\\"\\\\n    name: str\\\\n    kind: ParameterKind\\\\n    annotation: str | None = None\\\\n    default: str | None = None\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass Decorator:\\\\n    \\\"\\\"\\\"\\\\n    Represents a function decorator.\\\\n\\\\n    Attributes:\\\\n        name: The name of the decorator.\\\\n        args: A tuple of arguments passed to the decorator, as strings.\\\\n    \\\"\\\"\\\"\\\\n    name: str\\\\n    args: tuple[str, ...] = ()\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass FunctionContext:\\\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\\\n    pass\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass ModuleContext(FunctionContext):\\\\n    \\\"\\\"\\\"\\\\n    Represents a function defined at the module level.\\\\n\\\\n    Attributes:\\\\n        module_name: The name of the module.\\\\n    \\\"\\\"\\\"\\\\n    module_name: str\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass ClassContext(FunctionContext):\\\\n    \\\"\\\"\\\"\\\\n    Represents a function defined within a class.\\\\n\\\\n    Attributes:\\\\n        class_name: The name of the class.\\\\n        parent_context: The context in which the class is defined.\\\\n    \\\"\\\"\\\"\\\\n    class_name: str\\\\n    parent_context: FunctionContext\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass NestedContext(FunctionContext):\\\\n    \\\"\\\"\\\"\\\\n    Represents a function defined within another function.\\\\n\\\\n    Attributes:\\\\n        parent_function: The name of the enclosing function.\\\\n        parent_context: The context of the enclosing function.\\\\n    \\\"\\\"\\\"\\\\n    parent_function: str\\\\n    parent_context: FunctionContext\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass FunctionInfo:\\\\n    \\\"\\\"\\\"\\\\n    Stores complete metadata for a Python function.\\\\n\\\\n    Attributes:\\\\n        name: The name of the function.\\\\n        line_start: The starting line number of the function definition.\\\\n        line_end: The ending line number of the function definition.\\\\n        column_start: The starting column offset of the function definition.\\\\n        column_end: The ending column offset of the function definition.\\\\n        parameters: A tuple of Parameter objects for the function\\\\'s signature.\\\\n        decorators: A tuple of Decorator objects applied to the function.\\\\n        is_async: A boolean indicating if the function is asynchronous.\\\\n        context: The context (Module, Class, or Nested) where the function is defined.\\\\n        docstring: The function\\\\'s docstring, if present.\\\\n        return_annotation: The return type annotation as a string, if present.\\\\n    \\\"\\\"\\\"\\\\n    name: str\\\\n    line_start: int\\\\n    line_end: int\\\\n    column_start: int\\\\n    column_end: int\\\\n    parameters: tuple[Parameter, ...]\\\\n    decorators: tuple[Decorator, ...]\\\\n    is_async: bool\\\\n    context: FunctionContext\\\\n    docstring: str | None = None\\\\n    return_annotation: str | None = None\\\\n\\\\n    @classmethod\\\\n    def from_ast_node(\\\\n        cls: Type[\\\"FunctionInfo\\\"],\\\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n        context: FunctionContext,\\\\n    ) -> \\\"FunctionInfo\\\":\\\\n        \\\"\\\"\\\"\\\\n        Factory method to create a FunctionInfo instance from an AST node.\\\\n\\\\n        This method encapsulates the logic of extracting all function metadata\\\\n        from the AST, making the FunctionInfo class self-sufficient in its\\\\n        construction from a source AST node.\\\\n\\\\n        Args:\\\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\\\n            context: The context (Module, Class, or Nested) where the function is defined.\\\\n\\\\n        Returns:\\\\n            A new instance of FunctionInfo.\\\\n        \\\"\\\"\\\"\\\\n        return cls(\\\\n            name=node.name,\\\\n            line_start=node.lineno,\\\\n            line_end=node.end_lineno or node.lineno,\\\\n            column_start=node.col_offset,\\\\n            column_end=node.end_col_offset or node.col_offset,\\\\n            parameters=tuple(extract_parameters(node)),\\\\n            decorators=extract_decorators(node.decorator_list),\\\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\\\n            context=context,\\\\n            docstring=extract_docstring(node),\\\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\\\n        )\\\\n\\\\n\\\\ndef ast_node_to_source(node: ast.AST) -> str:\\\\n    \\\"\\\"\\\"\\\\n    Convert an AST node back to its source code representation.\\\\n\\\\n    Args:\\\\n        node: The AST node to convert.\\\\n\\\\n    Returns:\\\\n        The source code string for the node, or a repr for fallback.\\\\n    \\\"\\\"\\\"\\\\n    try:\\\\n        return ast.unparse(node)\\\\n    except Exception:\\\\n        return repr(node)\\\\n\\\\n\\\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\\\n    \\\"\\\"\\\"\\\\n    Extract decorator information from an AST decorator list.\\\\n\\\\n    Args:\\\\n        decorators: A list of decorator nodes from an AST function definition.\\\\n\\\\n    Returns:\\\\n        A tuple of Decorator objects.\\\\n    \\\"\\\"\\\"\\\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\\\n        match dec:\\\\n            case ast.Name(id=name):\\\\n                return Decorator(name=name)\\\\n            case ast.Call(func=func, args=args):\\\\n                # This single case handles decorators with arguments,\\\\n                # regardless of whether the decorator is a simple name or a complex expression.\\\\n                return Decorator(\\\\n                    name=ast_node_to_source(func),\\\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\\\n                )\\\\n            case _:\\\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\\\n                return Decorator(name=ast_node_to_source(dec))\\\\n\\\\n    return tuple(parse_decorator(dec) for dec in decorators)\\\\n\\\\n\\\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\\\n    \\\"\\\"\\\"\\\\n    Maps parameter names to their default value\\\\'s source string.\\\\n\\\\n    This helper centralizes the logic for extracting default values for both\\\\n    positional and keyword-only arguments from an `ast.arguments` node.\\\\n\\\\n    Args:\\\\n        args: The `ast.arguments` node from a function definition.\\\\n\\\\n    Returns:\\\\n        A dictionary mapping parameter names to their unparsed default values.\\\\n    \\\"\\\"\\\"\\\\n    defaults_map = {}\\\\n    \\\\n    # Positional and positional-or-keyword defaults\\\\n    all_positional_args = args.posonlyargs + args.args\\\\n    num_defaults = len(args.defaults)\\\\n    if num_defaults > 0:\\\\n        # Defaults apply to the last `num_defaults` arguments\\\\n        args_with_defaults = all_positional_args[-num_defaults:]\\\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\\\n\\\\n    # Keyword-only defaults\\\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\\\n        if default_node:\\\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\\\n            \\\\n    return defaults_map\\\\n\\\\n\\\\ndef extract_parameters(\\\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n) -> Iterator[Parameter]:\\\\n    \\\"\\\"\\\"\\\\n    Generate parameter information from a function\\\\'s AST node.\\\\n\\\\n    This function processes all parameter kinds in their correct order:\\\\n    positional-only, positional-or-keyword, var-positional (*args),\\\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\\\n    default values, simplifying the logic.\\\\n\\\\n    Args:\\\\n        func_node: The function definition node from the AST.\\\\n\\\\n    Yields:\\\\n        Parameter objects representing the function\\\\'s signature.\\\\n    \\\"\\\"\\\"\\\\n    args = func_node.args\\\\n    defaults = _map_parameter_defaults(args)\\\\n\\\\n    # 1. Positional-only parameters\\\\n    for arg in args.posonlyargs:\\\\n        yield Parameter(\\\\n            name=arg.arg,\\\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\\\n            default=defaults.get(arg.arg),\\\\n            kind=ParameterKind.POSITIONAL_ONLY,\\\\n        )\\\\n\\\\n    # 2. Positional-or-keyword parameters\\\\n    for arg in args.args:\\\\n        yield Parameter(\\\\n            name=arg.arg,\\\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\\\n            default=defaults.get(arg.arg),\\\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\\\n        )\\\\n\\\\n    # 3. Variadic positional parameter (*args)\\\\n    if args.vararg:\\\\n        yield Parameter(\\\\n            name=args.vararg.arg,\\\\n            annotation=(\\\\n                ast_node_to_source(args.vararg.annotation)\\\\n                if args.vararg.annotation\\\\n                else None\\\\n            ),\\\\n            kind=ParameterKind.VAR_POSITIONAL,\\\\n        )\\\\n\\\\n    # 4. Keyword-only parameters\\\\n    for arg in args.kwonlyargs:\\\\n        yield Parameter(\\\\n            name=arg.arg,\\\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\\\n            default=defaults.get(arg.arg),\\\\n            kind=ParameterKind.KEYWORD_ONLY,\\\\n        )\\\\n\\\\n    # 5. Variadic keyword parameter (**kwargs)\\\\n    if args.kwarg:\\\\n        yield Parameter(\\\\n            name=args.kwarg.arg,\\\\n            annotation=(\\\\n                ast_node_to_source(args.kwarg.annotation)\\\\n                if args.kwarg.annotation\\\\n                else None\\\\n            ),\\\\n            kind=ParameterKind.VAR_KEYWORD,\\\\n        )\\\\n\\\\n\\\\ndef extract_docstring(\\\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n) -> str | None:\\\\n    \\\"\\\"\\\"\\\\n    Extract the docstring from a function node using ast.get_docstring.\\\\n\\\\n    Args:\\\\n        func_node: The function definition node from the AST.\\\\n\\\\n    Returns:\\\\n        The docstring string, or None if not found.\\\\n    \\\"\\\"\\\"\\\\n    return ast.get_docstring(func_node, clean=False)\\\\n\\\\n\\\\nclass _FunctionVisitor:\\\\n    \\\"\\\"\\\"\\\\n    An internal AST visitor to find and yield all function definitions.\\\\n\\\\n    This class traverses an AST, keeping track of the definition context\\\\n    (module, class, or nested function) and yields a `FunctionInfo`\\\\n    object for each function it encounters.\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def visit(\\\\n        self, node: ast.AST, context: FunctionContext\\\\n    ) -> Iterator[FunctionInfo]:\\\\n        \\\"\\\"\\\"\\\\n        Recursively visit AST nodes and yield function information.\\\\n\\\\n        This method uses structural pattern matching to dispatch to more\\\\n        specific handlers based on the node type.\\\\n\\\\n        Args:\\\\n            node: The current AST node to visit.\\\\n            context: The current context (Module, Class, or Nested).\\\\n\\\\n        Yields:\\\\n            FunctionInfo objects for each function found.\\\\n        \\\"\\\"\\\"\\\\n        match node:\\\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\\\n                yield from self._visit_function_def(node, context)\\\\n            case ast.ClassDef():\\\\n                yield from self._visit_class_def(node, context)\\\\n            case _:\\\\n                for child in ast.iter_child_nodes(node):\\\\n                    yield from self.visit(child, context)\\\\n\\\\n    def _visit_function_def(\\\\n        self,\\\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n        context: FunctionContext,\\\\n    ) -> Iterator[FunctionInfo]:\\\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\\\n        # Use the factory method to create the FunctionInfo object\\\\n        yield FunctionInfo.from_ast_node(node, context)\\\\n\\\\n        # Recurse into the function body to find nested functions\\\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\\\n        for child in node.body:\\\\n            yield from self.visit(child, nested_context)\\\\n\\\\n    def _visit_class_def(\\\\n        self, node: ast.ClassDef, context: FunctionContext\\\\n    ) -> Iterator[FunctionInfo]:\\\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\\\n        for child in node.body:\\\\n            yield from self.visit(child, class_context)\\\\n\\\\n\\\\ndef _parse_ast_and_find_functions(\\\\n    tree: ast.Module, module_name: str\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Internal helper to process a parsed AST and yield function info.\\\\n\\\\n    Args:\\\\n        tree: The parsed AST module.\\\\n        module_name: The name of the module being parsed.\\\\n\\\\n    Yields:\\\\n        FunctionInfo objects for all functions in the AST.\\\\n    \\\"\\\"\\\"\\\\n    module_context = ModuleContext(module_name=module_name)\\\\n    visitor = _FunctionVisitor()\\\\n    yield from visitor.visit(tree, module_context)\\\\n\\\\n\\\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Parse a Python file and stream all function definitions.\\\\n\\\\n    Args:\\\\n        file_path: The path to the Python file.\\\\n\\\\n    Yields:\\\\n        FunctionInfo objects for all functions in the file.\\\\n    \\\"\\\"\\\"\\\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\\\n        source_code = f.read()\\\\n    tree = ast.parse(source_code, filename=str(file_path))\\\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\\\n\\\\n\\\\ndef parse_python_source(\\\\n    source_code: str, module_name: str = \\\"<string>\\\"\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Parse a Python source string and stream all function definitions.\\\\n\\\\n    Args:\\\\n        source_code: The Python code to parse.\\\\n        module_name: The name to associate with the module.\\\\n\\\\n    Yields:\\\\n        FunctionInfo objects for all functions in the code.\\\\n    \\\"\\\"\\\"\\\\n    tree = ast.parse(source_code, filename=module_name)\\\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\\\n\\\\n\\\\ndef filter_by_context(\\\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Filter functions by their context type (e.g., ClassContext).\\\\n\\\\n    Args:\\\\n        context_type: The context class to filter by (e.g., ClassContext).\\\\n        functions: An iterator of FunctionInfo objects to filter.\\\\n\\\\n    Yields:\\\\n        The functions that match the context type.\\\\n    \\\"\\\"\\\"\\\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\\\n\\\\n\\\\ndef filter_by_decorator(\\\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Filter functions that have a specific decorator.\\\\n\\\\n    Args:\\\\n        decorator_name: The name of the decorator to search for.\\\\n        functions: An iterator of FunctionInfo objects to filter.\\\\n\\\\n    Yields:\\\\n        The functions that have the specified decorator.\\\\n    \\\"\\\"\\\"\\\\n    yield from (\\\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\\\n    )\\\\n\\\\n\\\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\\\n    \\\"\\\"\\\"\\\\n    Extract just the names from a sequence of functions.\\\\n\\\\n    Args:\\\\n        functions: An iterator of FunctionInfo objects.\\\\n\\\\n    Yields:\\\\n        The function name strings.\\\\n    \\\"\\\"\\\"\\\\n    yield from (f.name for f in functions)\\\\n\\\\n\\\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Filter for and return only the asynchronous functions.\\\\n\\\\n    Args:\\\\n        functions: An iterator of FunctionInfo objects.\\\\n\\\\n    Yields:\\\\n        The async functions.\\\\n    \\\"\\\"\\\"\\\\n    yield from (f for f in functions if f.is_async)\\\\n\\\\n\\\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Get all functions defined within a class context (methods).\\\\n\\\\n    Args:\\\\n        functions: An iterator of FunctionInfo objects.\\\\n\\\\n    Yields:\\\\n        The functions defined in a ClassContext.\\\\n    \\\"\\\"\\\"\\\\n    yield from filter_by_context(ClassContext, functions)\\\\n\\\\n\\\\ndef format_function_signature(func: FunctionInfo) -> str:\\\\n    \\\"\\\"\\\"\\\\n    Format a function\\\\'s signature into a human-readable string.\\\\n\\\\n    This function correctly handles positional-only, keyword-only, and\\\\n    variadic parameters.\\\\n\\\\n    Args:\\\\n        func: The FunctionInfo object to format.\\\\n\\\\n    Returns:\\\\n        A string representing the function\\\\'s signature.\\\\n    \\\"\\\"\\\"\\\\n    def format_param(p: Parameter) -> str:\\\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\\\n        res = p.name\\\\n        if p.annotation:\\\\n            res += f\\\": {p.annotation}\\\"\\\\n        if p.default is not None:\\\\n            res += f\\\" = {p.default}\\\"\\\\n        return res\\\\n\\\\n    parts = []\\\\n    pos_only = [\\\\n        format_param(p)\\\\n        for p in func.parameters\\\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\\\n    ]\\\\n    pos_or_kw = [\\\\n        format_param(p)\\\\n        for p in func.parameters\\\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\\\n    ]\\\\n    kw_only = [\\\\n        format_param(p)\\\\n        for p in func.parameters\\\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\\\n    ]\\\\n    var_pos = next(\\\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\\\n        None,\\\\n    )\\\\n    var_kw = next(\\\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\\\n        None,\\\\n    )\\\\n\\\\n    if pos_only:\\\\n        parts.append(\\\", \\\".join(pos_only))\\\\n        # Add the separator for positional-only arguments.\\\\n        parts.append(\\\"/\\\")\\\\n    if pos_or_kw:\\\\n        parts.append(\\\", \\\".join(pos_or_kw))\\\\n    if var_pos:\\\\n        parts.append(var_pos)\\\\n    # If there are keyword-only args but no *args, a bare \\\\'*\\\\' is needed.\\\\n    elif kw_only:\\\\n        parts.append(\\\"*\\\")\\\\n    if kw_only:\\\\n        parts.append(\\\", \\\".join(kw_only))\\\\n    if var_kw:\\\\n        parts.append(var_kw)\\\\n\\\\n    params_str = \\\", \\\".join(part for part in parts if part)\\\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\\\n```',\\n    implementation_explanation=\\\"The refactoring was executed according to the plan to improve code organization and reduce complexity.\\\\n\\\\n1.  **Decorator Extraction Simplified:** The `extract_decorators` function was streamlined by merging two `ast.Call` match cases into a single, more general one. This removes redundant code while correctly handling decorators that are simple names, calls, or attributes.\\\\n\\\\n2.  **Centralized Default Value Logic:** A new private helper, `_map_parameter_defaults`, was created. This function encapsulates the complex logic of mapping parameter names to their default values, handling both positional and keyword-only arguments.\\\\n\\\\n3.  **Simplified Parameter Extraction:** The `extract_parameters` function was refactored to use `_map_parameter_defaults`. This eliminated brittle index calculations for default values, replacing them with a simple and robust dictionary lookup (`defaults.get(arg.arg)`), which significantly enhances readability and maintainability. The logic for variadic parameters (`*args`, `**kwargs`) was kept in separate blocks to preserve the mandatory syntactical order, as a single loop would have been incorrect.\\\\n\\\\n4.  **Factory Method for `FunctionInfo`:** A class method, `FunctionInfo.from_ast_node`, was introduced. The responsibility for instantiating a `FunctionInfo` object was moved from the `_FunctionVisitor` into this factory. This adheres to the Single Responsibility Principle, making `FunctionInfo` responsible for its own creation from an AST node and simplifying the visitor's logic.\\\\n\\\\n5.  **Visitor Simplification:** Consequently, the `_FunctionVisitor._visit_function_def` method was simplified to a single call to the new `FunctionInfo.from_ast_node` factory, making the visitor's role purely traversal and delegation.\\\\n\\\\nAll new and modified components were documented with clear docstrings and precise type hints, ensuring the refactored code is robust and easy to understand.\\\"\\n)\"]}", "mlflow.spanType": "\"CHAIN\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "xHb0p57r19E=", "trace_state": "", "parent_span_id": "VLt6SmiX6cQ=", "name": "Predict.forward_4", "start_time_unix_nano": 1750224131090940000, "end_time_unix_nano": 1750224147929824000, "attributes": {"mlflow.spanOutputs": "{\"final_score\": 0.94, \"final_suggestion\": \"This is an excellent submission. The code is functionally perfect, well-structured with low complexity, and features strong typing and comprehensive docstrings. The only area for improvement is stylistic, as indicated by the low linting score. These issues are minor, consisting primarily of lines exceeding the 79-character limit and some extraneous whitespace. Running an autoformatter like `black` would resolve these instantly. With that minor cleanup, the code is ready for production.\"}", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"quality_scores\": \"{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9423076923076923,\\\"docstring_score\\\":0.95,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:135:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:151:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:187:80: E501 line too long (95 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:193:80: E501 line too long (93 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:213:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:227:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:255:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:264:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:285:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:362:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:370:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:456:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:473:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:538:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:542:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:564:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:565:73: W292 no newline at end of file\\\"]}\", \"functional_score\": 1.0}", "mlflow.spanType": "\"LLM\"", "signature": "\"code_snippet, quality_scores, functional_score -> final_score, final_suggestion\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "qD3d9p27D+I=", "trace_state": "", "parent_span_id": "xHb0p57r19E=", "name": "ChatAdapter.format_4", "start_time_unix_nano": 1750224131091217000, "end_time_unix_nano": 1750224131092113000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The refactored code being evaluated.\\n2. `quality_scores` (str): A JSON object of quantitative scores (linting, complexity, typing, docstrings).\\n3. `functional_score` (float): A score from 0.0 to 1.0 indicating test pass rate.\\nYour output fields are:\\n1. `final_score` (float): A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.\\n2. `final_suggestion` (str): A final suggestion for improvement or a confirmation of readiness.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## quality_scores ## ]]\\n{quality_scores}\\n\\n[[ ## functional_score ## ]]\\n{functional_score}\\n\\n[[ ## final_score ## ]]\\n{final_score}        # note: the value you produce must be a single float value\\n\\n[[ ## final_suggestion ## ]]\\n{final_suggestion}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        Evaluate the refactored code based on quantitative scores and provide a final assessment.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## quality_scores ## ]]\\n{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9423076923076923,\\\"docstring_score\\\":0.95,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:135:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:151:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:187:80: E501 line too long (95 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:193:80: E501 line too long (93 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:213:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:227:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:255:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:264:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:285:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:362:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:370:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:456:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:473:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:538:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:542:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:564:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:565:73: W292 no newline at end of file\\\"]}\\n\\n[[ ## functional_score ## ]]\\n1.0\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## final_score ## ]]` (must be formatted as a valid Python float), then `[[ ## final_suggestion ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.spanInputs": "{\"signature\": \"EvaluationSignature(code_snippet, quality_scores, functional_score -> final_score, final_suggestion\\n    instructions='Evaluate the refactored code based on quantitative scores and provide a final assessment.'\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The refactored code being evaluated.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    quality_scores = Field(annotation=str required=True json_schema_extra={'desc': 'A JSON object of quantitative scores (linting, complexity, typing, docstrings).', '__dspy_field_type': 'input', 'prefix': 'Quality Scores:'})\\n    functional_score = Field(annotation=float required=True json_schema_extra={'desc': 'A score from 0.0 to 1.0 indicating test pass rate.', '__dspy_field_type': 'input', 'prefix': 'Functional Score:'})\\n    final_score = Field(annotation=float required=True json_schema_extra={'desc': 'A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.', '__dspy_field_type': 'output', 'prefix': 'Final Score:'})\\n    final_suggestion = Field(annotation=str required=True json_schema_extra={'desc': 'A final suggestion for improvement or a confirmation of readiness.', '__dspy_field_type': 'output', 'prefix': 'Final Suggestion:'})\\n)\", \"demos\": [], \"inputs\": {\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"quality_scores\": \"{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9423076923076923,\\\"docstring_score\\\":0.95,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:135:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:151:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:187:80: E501 line too long (95 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:193:80: E501 line too long (93 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:213:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:227:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:255:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:264:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:285:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:362:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:370:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:456:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:473:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:538:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:542:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:564:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:565:73: W292 no newline at end of file\\\"]}\", \"functional_score\": 1.0}}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "mujH+dbMP2s=", "trace_state": "", "parent_span_id": "xHb0p57r19E=", "name": "LM.__call___4", "start_time_unix_nano": 1750224131092184000, "end_time_unix_nano": 1750224147928472000, "attributes": {"mlflow.spanOutputs": "[\"[[ ## final_score ## ]]\\n0.94\\n\\n[[ ## final_suggestion ## ]]\\nThis is an excellent submission. The code is functionally perfect, well-structured with low complexity, and features strong typing and comprehensive docstrings. The only area for improvement is stylistic, as indicated by the low linting score. These issues are minor, consisting primarily of lines exceeding the 79-character limit and some extraneous whitespace. Running an autoformatter like `black` would resolve these instantly. With that minor cleanup, the code is ready for production.\\n\\n[[ ## completed ## ]]\"]", "temperature": "0.0", "cache": "true", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The refactored code being evaluated.\\n2. `quality_scores` (str): A JSON object of quantitative scores (linting, complexity, typing, docstrings).\\n3. `functional_score` (float): A score from 0.0 to 1.0 indicating test pass rate.\\nYour output fields are:\\n1. `final_score` (float): A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.\\n2. `final_suggestion` (str): A final suggestion for improvement or a confirmation of readiness.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## quality_scores ## ]]\\n{quality_scores}\\n\\n[[ ## functional_score ## ]]\\n{functional_score}\\n\\n[[ ## final_score ## ]]\\n{final_score}        # note: the value you produce must be a single float value\\n\\n[[ ## final_suggestion ## ]]\\n{final_suggestion}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        Evaluate the refactored code based on quantitative scores and provide a final assessment.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## quality_scores ## ]]\\n{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9423076923076923,\\\"docstring_score\\\":0.95,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:135:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:151:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:187:80: E501 line too long (95 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:193:80: E501 line too long (93 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:213:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:227:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:255:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:264:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:285:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:362:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:370:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:456:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:473:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:538:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:542:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:564:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:565:73: W292 no newline at end of file\\\"]}\\n\\n[[ ## functional_score ## ]]\\n1.0\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## final_score ## ]]` (must be formatted as a valid Python float), then `[[ ## final_suggestion ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The refactored code being evaluated.\\n2. `quality_scores` (str): A JSON object of quantitative scores (linting, complexity, typing, docstrings).\\n3. `functional_score` (float): A score from 0.0 to 1.0 indicating test pass rate.\\nYour output fields are:\\n1. `final_score` (float): A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.\\n2. `final_suggestion` (str): A final suggestion for improvement or a confirmation of readiness.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## quality_scores ## ]]\\n{quality_scores}\\n\\n[[ ## functional_score ## ]]\\n{functional_score}\\n\\n[[ ## final_score ## ]]\\n{final_score}        # note: the value you produce must be a single float value\\n\\n[[ ## final_suggestion ## ]]\\n{final_suggestion}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        Evaluate the refactored code based on quantitative scores and provide a final assessment.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n    @classmethod\\n    def from_ast_node(\\n        cls: Type[\\\"FunctionInfo\\\"],\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> \\\"FunctionInfo\\\":\\n        \\\"\\\"\\\"\\n        Factory method to create a FunctionInfo instance from an AST node.\\n\\n        This method encapsulates the logic of extracting all function metadata\\n        from the AST, making the FunctionInfo class self-sufficient in its\\n        construction from a source AST node.\\n\\n        Args:\\n            node: The AST node (FunctionDef or AsyncFunctionDef).\\n            context: The context (Module, Class, or Nested) where the function is defined.\\n\\n        Returns:\\n            A new instance of FunctionInfo.\\n        \\\"\\\"\\\"\\n        return cls(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=func, args=args):\\n                # This single case handles decorators with arguments,\\n                # regardless of whether the decorator is a simple name or a complex expression.\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args),\\n                )\\n            case _:\\n                # Fallback for other expressions like ast.Attribute (e.g., @pytest.mark.skip)\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _map_parameter_defaults(args: ast.arguments) -> dict[str, str]:\\n    \\\"\\\"\\\"\\n    Maps parameter names to their default value's source string.\\n\\n    This helper centralizes the logic for extracting default values for both\\n    positional and keyword-only arguments from an `ast.arguments` node.\\n\\n    Args:\\n        args: The `ast.arguments` node from a function definition.\\n\\n    Returns:\\n        A dictionary mapping parameter names to their unparsed default values.\\n    \\\"\\\"\\\"\\n    defaults_map = {}\\n    \\n    # Positional and positional-or-keyword defaults\\n    all_positional_args = args.posonlyargs + args.args\\n    num_defaults = len(args.defaults)\\n    if num_defaults > 0:\\n        # Defaults apply to the last `num_defaults` arguments\\n        args_with_defaults = all_positional_args[-num_defaults:]\\n        for arg, default_node in zip(args_with_defaults, args.defaults):\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n\\n    # Keyword-only defaults\\n    for arg, default_node in zip(args.kwonlyargs, args.kw_defaults):\\n        if default_node:\\n            defaults_map[arg.arg] = ast_node_to_source(default_node)\\n            \\n    return defaults_map\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs). It uses a helper to map\\n    default values, simplifying the logic.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    defaults = _map_parameter_defaults(args)\\n\\n    # 1. Positional-only parameters\\n    for arg in args.posonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    for arg in args.args:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for arg in args.kwonlyargs:\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=defaults.get(arg.arg),\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        # Use the factory method to create the FunctionInfo object\\n        yield FunctionInfo.from_ast_node(node, context)\\n\\n        # Recurse into the function body to find nested functions\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## quality_scores ## ]]\\n{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9423076923076923,\\\"docstring_score\\\":0.95,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:135:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:151:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:187:80: E501 line too long (95 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:193:80: E501 line too long (93 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:213:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:227:1: W293 blank line contains whitespace\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:255:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:264:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:285:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:362:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:370:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:456:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:473:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:538:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:542:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:564:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpsuv8qqss.py:565:73: W292 no newline at end of file\\\"]}\\n\\n[[ ## functional_score ## ]]\\n1.0\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## final_score ## ]]` (must be formatted as a valid Python float), then `[[ ## final_suggestion ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## final_score ## ]]\\n0.94\\n\\n[[ ## final_suggestion ## ]]\\nThis is an excellent submission. The code is functionally perfect, well-structured with low complexity, and features strong typing and comprehensive docstrings. The only area for improvement is stylistic, as indicated by the low linting score. These issues are minor, consisting primarily of lines exceeding the 79-character limit and some extraneous whitespace. Running an autoformatter like `black` would resolve these instantly. With that minor cleanup, the code is ready for production.\\n\\n[[ ## completed ## ]]\"}]", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\"", "max_tokens": "64000", "model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "mlflow.spanType": "\"CHAT_MODEL\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "BIQ4p97u5BJFznfwujnfig==", "span_id": "qMTtLHfExg0=", "trace_state": "", "parent_span_id": "xHb0p57r19E=", "name": "ChatAdapter.parse_4", "start_time_unix_nano": 1750224147928787000, "end_time_unix_nano": 1750224147929692000, "attributes": {"mlflow.spanOutputs": "{\"final_score\": 0.94, \"final_suggestion\": \"This is an excellent submission. The code is functionally perfect, well-structured with low complexity, and features strong typing and comprehensive docstrings. The only area for improvement is stylistic, as indicated by the low linting score. These issues are minor, consisting primarily of lines exceeding the 79-character limit and some extraneous whitespace. Running an autoformatter like `black` would resolve these instantly. With that minor cleanup, the code is ready for production.\"}", "mlflow.spanInputs": "{\"signature\": \"EvaluationSignature(code_snippet, quality_scores, functional_score -> final_score, final_suggestion\\n    instructions='Evaluate the refactored code based on quantitative scores and provide a final assessment.'\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The refactored code being evaluated.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    quality_scores = Field(annotation=str required=True json_schema_extra={'desc': 'A JSON object of quantitative scores (linting, complexity, typing, docstrings).', '__dspy_field_type': 'input', 'prefix': 'Quality Scores:'})\\n    functional_score = Field(annotation=float required=True json_schema_extra={'desc': 'A score from 0.0 to 1.0 indicating test pass rate.', '__dspy_field_type': 'input', 'prefix': 'Functional Score:'})\\n    final_score = Field(annotation=float required=True json_schema_extra={'desc': 'A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.', '__dspy_field_type': 'output', 'prefix': 'Final Score:'})\\n    final_suggestion = Field(annotation=str required=True json_schema_extra={'desc': 'A final suggestion for improvement or a confirmation of readiness.', '__dspy_field_type': 'output', 'prefix': 'Final Suggestion:'})\\n)\", \"completion\": \"[[ ## final_score ## ]]\\n0.94\\n\\n[[ ## final_suggestion ## ]]\\nThis is an excellent submission. The code is functionally perfect, well-structured with low complexity, and features strong typing and comprehensive docstrings. The only area for improvement is stylistic, as indicated by the low linting score. These issues are minor, consisting primarily of lines exceeding the 79-character limit and some extraneous whitespace. Running an autoformatter like `black` would resolve these instantly. With that minor cleanup, the code is ready for production.\\n\\n[[ ## completed ## ]]\"}", "mlflow.spanType": "\"PARSER\"", "mlflow.traceRequestId": "\"ad953d5702cc421b9690f74712b4f7ae\""}, "status": {"message": "", "code": "STATUS_CODE_OK"}}]}