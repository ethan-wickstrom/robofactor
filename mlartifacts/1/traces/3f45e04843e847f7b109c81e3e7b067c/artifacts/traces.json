{"spans": [{"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "JDincGPsQL0=", "trace_state": "", "parent_span_id": "", "name": "Refine.forward", "start_time_unix_nano": 1750223675598064000, "end_time_unix_nano": 1750223813504404000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\", \"refactoring_opportunities\": [\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\", \"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\", \"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\", \"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\", \"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\"], \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\", \"plan_steps\": [\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\", \"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\", \"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\", \"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\", \"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\", \"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\", \"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\"], \"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\"}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "xjl/F4m3Tno=", "trace_state": "", "parent_span_id": "JDincGPsQL0=", "name": "CodeRefactor.forward", "start_time_unix_nano": 1750223675598636000, "end_time_unix_nano": 1750223797066255000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\", \"refactoring_opportunities\": [\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\", \"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\", \"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\", \"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\", \"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\"], \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\", \"plan_steps\": [\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\", \"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\", \"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\", \"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\", \"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\", \"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\", \"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\"], \"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\"}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "W+l4wnPBcIM=", "trace_state": "", "parent_span_id": "xjl/F4m3Tno=", "name": "Predict.forward_1", "start_time_unix_nano": 1750223675598818000, "end_time_unix_nano": 1750223704085000000, "attributes": {"mlflow.spanType": "\"LLM\"", "mlflow.spanOutputs": "{\"analysis\": \"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\", \"refactoring_opportunities\": [\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\", \"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\", \"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\", \"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\", \"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\"]}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "signature": "\"code_snippet -> analysis, refactoring_opportunities\"", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "2wehQ9kyEdE=", "trace_state": "", "parent_span_id": "W+l4wnPBcIM=", "name": "ChatAdapter.format_1", "start_time_unix_nano": 1750223675598979000, "end_time_unix_nano": 1750223675600484000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The Python code to be analyzed.\\nYour output fields are:\\n1. `analysis` (str): A concise summary of the code's functionality and complexity.\\n2. `refactoring_opportunities` (list[str]): A bulleted list of specific, actionable refactoring opportunities.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_opportunities ## ]]\\n{refactoring_opportunities}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\n        \\n        For the provided code snippet:\\n        - Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\n        - Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\n        \\n        Ensure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The summation of `res` can be done more concisely using the built-in `sum()` function.\\\", \\\"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\\\", \\\"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## analysis ## ]]`, then `[[ ## refactoring_opportunities ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet -> analysis, refactoring_opportunities\\n    instructions=\\\"You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\\\n\\\\nFor the provided code snippet:\\\\n- Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\\\n- Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\\\n\\\\nEnsure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The Python code to be analyzed.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': \\\"A concise summary of the code's functionality and complexity.\\\", '__dspy_field_type': 'output', 'prefix': 'Analysis:'})\\n    refactoring_opportunities = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A bulleted list of specific, actionable refactoring opportunities.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Opportunities:'})\\n)\", \"demos\": [{\"augmented\": true, \"code_snippet\": \"\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\", \"analysis\": \"The Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\", \"refactoring_opportunities\": [\"The summation of `res` can be done more concisely using the built-in `sum()` function.\", \"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\", \"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\"]}], \"inputs\": {\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "hfJhHxNbk4o=", "trace_state": "", "parent_span_id": "W+l4wnPBcIM=", "name": "LM.__call___1", "start_time_unix_nano": 1750223675600571000, "end_time_unix_nano": 1750223704083541000, "attributes": {"model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "temperature": "0.0", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "cache": "true", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The Python code to be analyzed.\\nYour output fields are:\\n1. `analysis` (str): A concise summary of the code's functionality and complexity.\\n2. `refactoring_opportunities` (list[str]): A bulleted list of specific, actionable refactoring opportunities.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_opportunities ## ]]\\n{refactoring_opportunities}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\n        \\n        For the provided code snippet:\\n        - Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\n        - Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\n        \\n        Ensure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The summation of `res` can be done more concisely using the built-in `sum()` function.\\\", \\\"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\\\", \\\"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## analysis ## ]]`, then `[[ ## refactoring_opportunities ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\\\", \\\"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\\\", \\\"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\\\", \\\"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\\\", \\\"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\\\"]\\n\\n[[ ## completed ## ]]\"}]", "mlflow.spanOutputs": "[\"[[ ## analysis ## ]]\\nThe code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\\\", \\\"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\\\", \\\"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\\\", \\\"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\\\", \\\"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\\\"]\\n\\n[[ ## completed ## ]]\"]", "mlflow.spanType": "\"CHAT_MODEL\"", "max_tokens": "64000", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The Python code to be analyzed.\\nYour output fields are:\\n1. `analysis` (str): A concise summary of the code's functionality and complexity.\\n2. `refactoring_opportunities` (list[str]): A bulleted list of specific, actionable refactoring opportunities.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_opportunities ## ]]\\n{refactoring_opportunities}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\n        \\n        For the provided code snippet:\\n        - Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\n        - Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\n        \\n        Ensure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\"}, {\"role\": \"assistant\", \"content\": \"[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The summation of `res` can be done more concisely using the built-in `sum()` function.\\\", \\\"Consider renaming the `d` parameter to something more descriptive, like `items_data`.\\\", \\\"The tax rate could be defined as a constant at the beginning of the function or module for better readability and maintainability.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## analysis ## ]]`, then `[[ ## refactoring_opportunities ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "kuRz31aJPlw=", "trace_state": "", "parent_span_id": "W+l4wnPBcIM=", "name": "ChatAdapter.parse_1", "start_time_unix_nano": 1750223704083884000, "end_time_unix_nano": 1750223704084874000, "attributes": {"mlflow.spanOutputs": "{\"analysis\": \"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\", \"refactoring_opportunities\": [\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\", \"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\", \"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\", \"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\", \"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\"]}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet -> analysis, refactoring_opportunities\\n    instructions=\\\"You are an expert Python code analyst tasked with thoroughly examining a given Python code snippet that processes structured data, such as lists of dictionaries involving keys like 'price' and 'qty'. Your goal is to analyze the code's purpose, functionality, complexity, and potential areas for improvement, drawing from best practices in data manipulation, calculations, filtering, and business logic applications.\\\\n\\\\nFor the provided code snippet:\\\\n- Provide a concise summary that describes the code's overall functionality (e.g., what it does, such as calculating totals or applying taxes), its complexity level (e.g., low, involving simple loops or comprehensions), and any key features or potential issues.\\\\n- Generate a bulleted list of specific, actionable refactoring opportunities, focusing on enhancements like improving readability, efficiency, reducing redundancy, adhering to PEP8 standards, adding type hints, docstrings, or using built-in functions for better performance and maintainability.\\\\n\\\\nEnsure your response is clear, objective, and directly useful for subsequent steps in a refactoring pipeline. Base your analysis on standard Python practices and consider real-world applications in areas like finance or inventory management.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The Python code to be analyzed.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': \\\"A concise summary of the code's functionality and complexity.\\\", '__dspy_field_type': 'output', 'prefix': 'Analysis:'})\\n    refactoring_opportunities = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A bulleted list of specific, actionable refactoring opportunities.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Opportunities:'})\\n)\", \"completion\": \"[[ ## analysis ## ]]\\nThe code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\n\\n[[ ## refactoring_opportunities ## ]]\\n[\\\"The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.\\\", \\\"The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.\\\", \\\"In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.\\\", \\\"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\\\", \\\"The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.\\\"]\\n\\n[[ ## completed ## ]]\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "MRskVqkHCYQ=", "trace_state": "", "parent_span_id": "xjl/F4m3Tno=", "name": "Predict.forward_2", "start_time_unix_nano": 1750223704085157000, "end_time_unix_nano": 1750223739846850000, "attributes": {"mlflow.spanType": "\"LLM\"", "mlflow.spanOutputs": "{\"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\", \"plan_steps\": [\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\", \"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\", \"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\", \"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\", \"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\", \"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\", \"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\"]}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "signature": "\"code_snippet, analysis -> refactoring_summary, plan_steps\"", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"analysis\": \"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "OzaHJy2SgOQ=", "trace_state": "", "parent_span_id": "MRskVqkHCYQ=", "name": "ChatAdapter.format_2", "start_time_unix_nano": 1750223704085458000, "end_time_unix_nano": 1750223704086885000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The original Python code snippet.\\n2. `analysis` (str): The analysis of the code snippet.\\nYour output fields are:\\n1. `refactoring_summary` (str): A high-level summary of the refactoring goal.\\n2. `plan_steps` (list[str]): A detailed, step-by-step list of actions to refactor the code.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\n        \\n        1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\n        \\n        2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\n        \\n        Ensure your response is structured as follows:\\n        - **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\n        - **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\n        \\n        Base your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## analysis ## ]]\\nThe code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactoring_summary ## ]]`, then `[[ ## plan_steps ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet, analysis -> refactoring_summary, plan_steps\\n    instructions=\\\"You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\\\n\\\\n1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\\\n\\\\n2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\\\n\\\\nEnsure your response is structured as follows:\\\\n- **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\\\n- **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\\\n\\\\nBase your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The original Python code snippet.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': 'The analysis of the code snippet.', '__dspy_field_type': 'input', 'prefix': 'Analysis:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'A high-level summary of the refactoring goal.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A detailed, step-by-step list of actions to refactor the code.', '__dspy_field_type': 'output', 'prefix': 'Plan Steps:'})\\n)\", \"demos\": [{\"augmented\": true, \"code_snippet\": \"\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\", \"analysis\": \"The Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\", \"refactoring_summary\": \"Simplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\", \"plan_steps\": [\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\", \"Remove the intermediate `total` variable.\", \"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\", \"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\"]}], \"inputs\": {\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"analysis\": \"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\"}}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "rOXJ6mHQb/M=", "trace_state": "", "parent_span_id": "MRskVqkHCYQ=", "name": "LM.__call___2", "start_time_unix_nano": 1750223704086995000, "end_time_unix_nano": 1750223739845508000, "attributes": {"model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "temperature": "0.0", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "cache": "true", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The original Python code snippet.\\n2. `analysis` (str): The analysis of the code snippet.\\nYour output fields are:\\n1. `refactoring_summary` (str): A high-level summary of the refactoring goal.\\n2. `plan_steps` (list[str]): A detailed, step-by-step list of actions to refactor the code.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\n        \\n        1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\n        \\n        2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\n        \\n        Ensure your response is structured as follows:\\n        - **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\n        - **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\n        \\n        Base your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## analysis ## ]]\\nThe code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactoring_summary ## ]]`, then `[[ ## plan_steps ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\\\", \\\"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\\\", \\\"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\\\", \\\"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\\\", \\\"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\\\", \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", \\\"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\\\"]\"}]", "mlflow.spanOutputs": "[\"[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\\\", \\\"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\\\", \\\"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\\\", \\\"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\\\", \\\"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\\\", \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", \\\"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\\\"]\"]", "mlflow.spanType": "\"CHAT_MODEL\"", "max_tokens": "64000", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The original Python code snippet.\\n2. `analysis` (str): The analysis of the code snippet.\\nYour output fields are:\\n1. `refactoring_summary` (str): A high-level summary of the refactoring goal.\\n2. `plan_steps` (list[str]): A detailed, step-by-step list of actions to refactor the code.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## analysis ## ]]\\n{analysis}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}        # note: the value you produce must adhere to the JSON schema: {\\\"type\\\": \\\"array\\\", \\\"items\\\": {\\\"type\\\": \\\"string\\\"}}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\n        \\n        1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\n        \\n        2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\n        \\n        Ensure your response is structured as follows:\\n        - **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\n        - **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\n        \\n        Base your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## analysis ## ]]\\nThe Python code defines a function `process_data` that takes a list of dictionaries `d` as input. It calculates the total cost of items with a quantity greater than 0, applies an 8% tax, and returns the final total. The complexity is low, involving a list comprehension and a simple loop for summation.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## analysis ## ]]\\nThe code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactoring_summary ## ]]`, then `[[ ## plan_steps ## ]]` (must be formatted as a valid Python list[str]), and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "LVfutOhS8Po=", "trace_state": "", "parent_span_id": "MRskVqkHCYQ=", "name": "ChatAdapter.parse_2", "start_time_unix_nano": 1750223739845771000, "end_time_unix_nano": 1750223739846746000, "attributes": {"mlflow.spanOutputs": "{\"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\", \"plan_steps\": [\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\", \"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\", \"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\", \"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\", \"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\", \"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\", \"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\"]}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"StringSignature(code_snippet, analysis -> refactoring_summary, plan_steps\\n    instructions=\\\"You are an expert Python developer specializing in code refactoring. Given a Python code snippet and its analysis, which includes a summary of the code's functionality, complexity, and identified refactoring opportunities, your task is to generate:\\\\n\\\\n1. A high-level refactoring summary that clearly outlines the main goals of the refactoring, focusing on improving code readability, efficiency, and adherence to best practices like PEP8, type hints, and docstrings.\\\\n\\\\n2. A detailed, step-by-step list of actionable actions to refactor the code. Each step should be specific, practical, and directly address issues from the analysis, such as simplifying structures, removing redundancies, or enhancing maintainability.\\\\n\\\\nEnsure your response is structured as follows:\\\\n- **Refactoring Summary:** [Provide a concise paragraph summarizing the overall refactoring objectives.]\\\\n- **Plan Steps:** [List each step as a bulleted item, making it clear and implementable, based on the code's context.]\\\\n\\\\nBase your plan on the provided analysis to ensure it is targeted and effective, drawing from examples where similar code simplifications (e.g., replacing loops with built-in functions like sum()) have been applied.\\\"\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The original Python code snippet.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    analysis = Field(annotation=str required=True json_schema_extra={'desc': 'The analysis of the code snippet.', '__dspy_field_type': 'input', 'prefix': 'Analysis:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'A high-level summary of the refactoring goal.', '__dspy_field_type': 'output', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'A detailed, step-by-step list of actions to refactor the code.', '__dspy_field_type': 'output', 'prefix': 'Plan Steps:'})\\n)\", \"completion\": \"[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\\\", \\\"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\\\", \\\"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\\\", \\\"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\\\", \\\"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\\\", \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", \\\"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\\\"]\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "pGKfixJKnKk=", "trace_state": "", "parent_span_id": "xjl/F4m3Tno=", "name": "Predict.forward_3", "start_time_unix_nano": 1750223739847013000, "end_time_unix_nano": 1750223797066043000, "attributes": {"mlflow.spanType": "\"LLM\"", "mlflow.spanOutputs": "{\"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\"}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "signature": "\"original_code, refactoring_summary, plan_steps -> refactored_code, implementation_explanation\"", "mlflow.spanInputs": "{\"original_code\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\", \"plan_steps\": [\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\", \"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\", \"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\", \"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\", \"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\", \"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\", \"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\"]}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "uPoFoVRkDCk=", "trace_state": "", "parent_span_id": "pGKfixJKnKk=", "name": "ChatAdapter.format_3", "start_time_unix_nano": 1750223739847323000, "end_time_unix_nano": 1750223739848791000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `original_code` (str): The original, un-refactored Python code.\\n2. `refactoring_summary` (str): The high-level goal of the refactoring.\\n3. `plan_steps` (list[str]): The step-by-step plan to apply.\\nYour output fields are:\\n1. `refactored_code` (str): The final, PEP8-compliant, refactored Python code block with type hints and docstrings.\\n2. `implementation_explanation` (str): A brief explanation of how the plan was implemented.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## original_code ## ]]\\n{original_code}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}\\n\\n[[ ## refactored_code ## ]]\\n{refactored_code}\\n\\n[[ ## implementation_explanation ## ]]\\n{implementation_explanation}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\n        \\n        Inputs:\\n        - Original Code: The initial Python code snippet that needs refactoring.\\n        - Refactoring Summary: A high-level overview of the refactoring goals.\\n        - Plan Steps: A list of specific, step-by-step actions to apply.\\n        \\n        Outputs:\\n        - Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\n.\\n        - Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\n        \\n        Be precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\\\", \\\"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\\\", \\\"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\\\", \\\"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\\\", \\\"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\\\", \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", \\\"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\\\"]\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactored_code ## ]]`, then `[[ ## implementation_explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"StringSignature(original_code, refactoring_summary, plan_steps -> refactored_code, implementation_explanation\\n    instructions=\\\"You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\\\n\\\\nInputs:\\\\n- Original Code: The initial Python code snippet that needs refactoring.\\\\n- Refactoring Summary: A high-level overview of the refactoring goals.\\\\n- Plan Steps: A list of specific, step-by-step actions to apply.\\\\n\\\\nOutputs:\\\\n- Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\\\\\n.\\\\n- Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\\\n\\\\nBe precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\\\"\\n    original_code = Field(annotation=str required=True json_schema_extra={'desc': 'The original, un-refactored Python code.', '__dspy_field_type': 'input', 'prefix': 'Original Code:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'The high-level goal of the refactoring.', '__dspy_field_type': 'input', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'The step-by-step plan to apply.', '__dspy_field_type': 'input', 'prefix': 'Plan Steps:'})\\n    refactored_code = Field(annotation=str required=True json_schema_extra={'prefix': '```python\\\\n', 'desc': 'The final, PEP8-compliant, refactored Python code block with type hints and docstrings.', '__dspy_field_type': 'output'})\\n    implementation_explanation = Field(annotation=str required=True json_schema_extra={'desc': 'A brief explanation of how the plan was implemented.', '__dspy_field_type': 'output', 'prefix': 'Implementation Explanation:'})\\n)\", \"demos\": [{\"augmented\": true, \"original_code\": \"\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\", \"refactoring_summary\": \"Simplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\", \"plan_steps\": [\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\", \"Remove the intermediate `total` variable.\", \"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\", \"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\"], \"refactored_code\": \"```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\", \"implementation_explanation\": \"The refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}], \"inputs\": {\"original_code\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"refactoring_summary\": \"The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\", \"plan_steps\": [\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\", \"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\", \"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\", \"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\", \"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\", \"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\", \"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\"]}}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "PjEZLvhQrmI=", "trace_state": "", "parent_span_id": "pGKfixJKnKk=", "name": "LM.__call___3", "start_time_unix_nano": 1750223739848921000, "end_time_unix_nano": 1750223797064375000, "attributes": {"model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "temperature": "0.0", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "cache": "true", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `original_code` (str): The original, un-refactored Python code.\\n2. `refactoring_summary` (str): The high-level goal of the refactoring.\\n3. `plan_steps` (list[str]): The step-by-step plan to apply.\\nYour output fields are:\\n1. `refactored_code` (str): The final, PEP8-compliant, refactored Python code block with type hints and docstrings.\\n2. `implementation_explanation` (str): A brief explanation of how the plan was implemented.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## original_code ## ]]\\n{original_code}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}\\n\\n[[ ## refactored_code ## ]]\\n{refactored_code}\\n\\n[[ ## implementation_explanation ## ]]\\n{implementation_explanation}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\n        \\n        Inputs:\\n        - Original Code: The initial Python code snippet that needs refactoring.\\n        - Refactoring Summary: A high-level overview of the refactoring goals.\\n        - Plan Steps: A list of specific, step-by-step actions to apply.\\n        \\n        Outputs:\\n        - Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\n.\\n        - Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\n        \\n        Be precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\\\", \\\"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\\\", \\\"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\\\", \\\"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\\\", \\\"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\\\", \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", \\\"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\\\"]\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactored_code ## ]]`, then `[[ ## implementation_explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\\n\\n[[ ## completed ## ]]\"}]", "mlflow.spanOutputs": "[\"[[ ## refactored_code ## ]]\\n```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\\n\\n[[ ## completed ## ]]\"]", "mlflow.spanType": "\"CHAT_MODEL\"", "max_tokens": "64000", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `original_code` (str): The original, un-refactored Python code.\\n2. `refactoring_summary` (str): The high-level goal of the refactoring.\\n3. `plan_steps` (list[str]): The step-by-step plan to apply.\\nYour output fields are:\\n1. `refactored_code` (str): The final, PEP8-compliant, refactored Python code block with type hints and docstrings.\\n2. `implementation_explanation` (str): A brief explanation of how the plan was implemented.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## original_code ## ]]\\n{original_code}\\n\\n[[ ## refactoring_summary ## ]]\\n{refactoring_summary}\\n\\n[[ ## plan_steps ## ]]\\n{plan_steps}\\n\\n[[ ## refactored_code ## ]]\\n{refactored_code}\\n\\n[[ ## implementation_explanation ## ]]\\n{implementation_explanation}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\n        \\n        Inputs:\\n        - Original Code: The initial Python code snippet that needs refactoring.\\n        - Refactoring Summary: A high-level overview of the refactoring goals.\\n        - Plan Steps: A list of specific, step-by-step actions to apply.\\n        \\n        Outputs:\\n        - Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\n.\\n        - Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\n        \\n        Be precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\n\\ndef process_data(d):\\n    res = [x['price'] * x['qty'] for x in d if x['qty'] > 0]\\n    total = 0\\n    for r in res:\\n        total += r\\n    tax = 0.08\\n    final_total = total * (1 + tax)\\n    return final_total\\n\\n\\n[[ ## refactoring_summary ## ]]\\nSimplify the `process_data` function by combining the list comprehension and summation into a single generator expression with `sum()`, and by directly calculating the final total without an intermediate `total` variable.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Replace the list comprehension `[x['price'] * x['qty'] for x in d if x['qty'] > 0]` and the subsequent loop for summation with a single `sum()` call using a generator expression: `sum(x['price'] * x['qty'] for x in d if x['qty'] > 0)`.\\\", \\\"Remove the intermediate `total` variable.\\\", \\\"Combine the summation and tax calculation into a single return statement: `return sum(x['price'] * x['qty'] for x in d if x['qty'] > 0) * (1 + tax)`.\\\", \\\"Ensure the `tax` variable is defined within the function or passed as an argument if it needs to be dynamic.\\\"]\"}, {\"role\": \"assistant\", \"content\": \"[[ ## refactored_code ## ]]\\n```python\\nfrom typing import List, Dict, Union\\n\\ndef process_data(data: List[Dict[str, Union[int, float]]], tax_rate: float = 0.08) -> float:\\n    \\\"\\\"\\\"\\n    Calculates the final total cost of items after applying a tax rate.\\n\\n    Args:\\n        data: A list of dictionaries, where each dictionary represents an item\\n              and must contain 'price' and 'qty' keys.\\n        tax_rate: The tax rate to be applied to the total cost. Defaults to 0.08.\\n\\n    Returns:\\n        The final total cost including tax.\\n    \\\"\\\"\\\"\\n    return sum(item['price'] * item['qty'] for item in data if item['qty'] > 0) * (1 + tax_rate)\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was implemented by directly using a generator expression within the `sum()` function to calculate the subtotal of items with a positive quantity. This eliminated the need for an intermediate list and a separate loop for summation. The `total` variable was removed, and the tax calculation was combined with the summation into a single return statement. The `tax` variable was made a parameter with a default value to allow for flexibility. Type hints and a docstring were added for clarity and maintainability.\"}, {\"role\": \"user\", \"content\": \"[[ ## original_code ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## refactoring_summary ## ]]\\nThe primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.\\n\\n[[ ## plan_steps ## ]]\\n[\\\"Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.\\\", \\\"Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.\\\", \\\"Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).\\\", \\\"Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.\\\", \\\"Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.\\\", \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", \\\"In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.\\\"]\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## refactored_code ## ]]`, then `[[ ## implementation_explanation ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "lk5IvSfugag=", "trace_state": "", "parent_span_id": "pGKfixJKnKk=", "name": "ChatAdapter.parse_3", "start_time_unix_nano": 1750223797064643000, "end_time_unix_nano": 1750223797065841000, "attributes": {"mlflow.spanOutputs": "{\"refactored_code\": \"```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\", \"implementation_explanation\": \"The refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\"}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"StringSignature(original_code, refactoring_summary, plan_steps -> refactored_code, implementation_explanation\\n    instructions=\\\"You are a highly skilled Python refactoring expert working on a critical mission for a major financial institution. Imagine that this code is part of a live trading system where any inefficiencies or bugs could lead to millions in losses during peak market hours. Your task is to generate refactored, PEP8-compliant Python code based on the provided original code, refactoring summary, and detailed step-by-step plan. Ensure the refactored code includes type hints and docstrings for maximum readability and maintainability. Additionally, provide a clear explanation of how you implemented the plan, justifying every change to prevent potential errors that could crash the system or cause financial discrepancies.\\\\n\\\\nInputs:\\\\n- Original Code: The initial Python code snippet that needs refactoring.\\\\n- Refactoring Summary: A high-level overview of the refactoring goals.\\\\n- Plan Steps: A list of specific, step-by-step actions to apply.\\\\n\\\\nOutputs:\\\\n- Refactored Code: The final, optimized Python code block, prefixed with ```python\\\\\\\\n.\\\\n- Implementation Explanation: A brief, concise description of how the plan was executed, highlighting improvements and adherence to best practices.\\\\n\\\\nBe precise, thorough, and double-check your work as if your job and the company's stability depend on it—because in this high-stakes scenario, they do.\\\"\\n    original_code = Field(annotation=str required=True json_schema_extra={'desc': 'The original, un-refactored Python code.', '__dspy_field_type': 'input', 'prefix': 'Original Code:'})\\n    refactoring_summary = Field(annotation=str required=True json_schema_extra={'desc': 'The high-level goal of the refactoring.', '__dspy_field_type': 'input', 'prefix': 'Refactoring Summary:'})\\n    plan_steps = Field(annotation=List[str] required=True json_schema_extra={'desc': 'The step-by-step plan to apply.', '__dspy_field_type': 'input', 'prefix': 'Plan Steps:'})\\n    refactored_code = Field(annotation=str required=True json_schema_extra={'prefix': '```python\\\\n', 'desc': 'The final, PEP8-compliant, refactored Python code block with type hints and docstrings.', '__dspy_field_type': 'output'})\\n    implementation_explanation = Field(annotation=str required=True json_schema_extra={'desc': 'A brief explanation of how the plan was implemented.', '__dspy_field_type': 'output', 'prefix': 'Implementation Explanation:'})\\n)\", \"completion\": \"[[ ## refactored_code ## ]]\\n```python\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n```\\n\\n[[ ## implementation_explanation ## ]]\\nThe refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\n\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\n\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\n\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\n\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\n\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\n\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\\n\\n[[ ## completed ## ]]\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "PABuF5vNfPQ=", "trace_state": "", "parent_span_id": "JDincGPsQL0=", "name": "RefactoringEvaluator.forward", "start_time_unix_nano": 1750223797066407000, "end_time_unix_nano": 1750223813504051000, "attributes": {"mlflow.spanOutputs": "0.92", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"CHAIN\"", "mlflow.spanInputs": "{\"args\": [{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        if isinstance(dec, ast.Name):\\n            return Decorator(name=dec.id)\\n        if isinstance(dec, ast.Call):\\n            name = (\\n                dec.func.id\\n                if isinstance(dec.func, ast.Name)\\n                else ast_node_to_source(dec.func)\\n            )\\n            args = tuple(ast_node_to_source(arg) for arg in dec.args)\\n            return Decorator(name=name, args=args)\\n        return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef _extract_positional_only_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields positional-only parameters from an ast.arguments object.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n\\ndef _extract_regular_params(\\n    args: ast.arguments, defaults_start_index: int\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields regular (positional-or-keyword) parameters.\\\"\\\"\\\"\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n\\ndef _extract_var_positional_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic positional parameter (*args).\\\"\\\"\\\"\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n\\ndef _extract_keyword_only_params(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields keyword-only parameters.\\\"\\\"\\\"\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n\\ndef _extract_var_keyword_param(args: ast.arguments) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"Yields the variadic keyword parameter (**kwargs).\\\"\\\"\\\"\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_parameters(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    yield from _extract_positional_only_params(args, defaults_start_index)\\n    yield from _extract_regular_params(args, defaults_start_index)\\n    yield from _extract_var_positional_param(args)\\n    yield from _extract_keyword_only_params(args)\\n    yield from _extract_var_keyword_param(args)\\n\\n\\ndef extract_docstring(\\n    func_node: ast.FunctionDef | ast.AsyncFunctionDef,\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"An AST visitor to find and yield all function definitions.\\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method dispatches to more specific handlers based on node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\\n            yield from self._visit_function_def(node, context)\\n        elif isinstance(node, ast.ClassDef):\\n            yield from self._visit_class_def(node, context)\\n        else:\\n            for child in ast.iter_child_nodes(node):\\n                yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    module_context = ModuleContext(module_name=file_path.stem)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef filter_by_context(\\n    context_type: type, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\"}, \"Prediction(\\n    analysis=\\\"The code provides a robust toolkit for statically analyzing Python source code to extract detailed metadata about functions. It uses the `ast` module to parse code from files or strings into an Abstract Syntax Tree. A visitor class traverses the tree to find all function definitions, including nested functions and methods within classes. The extracted information, such as parameters, decorators, docstrings, and context (module, class, or nested), is stored in well-defined `dataclass` structures. The complexity is moderate, as it requires a solid understanding of Python's AST structure and function signature rules. The code is well-organized, uses modern Python features like type hints and dataclasses, and employs generators for memory-efficient processing.\\\",\\n    refactoring_opportunities=['The helper functions `_extract_positional_only_params` and `_extract_regular_params` contain very similar logic for calculating default value indices. They could be refactored into a single, more generic helper to reduce code duplication.', 'The parameter extraction helpers (`_extract_*_params`) are only used by the `extract_parameters` function. They could be nested inside `extract_parameters` to encapsulate their logic and reduce module-level namespace pollution.', 'In `_visit_function_def`, the fallbacks for `end_lineno` and `end_col_offset` (e.g., `node.end_lineno or node.lineno`) should include a comment explaining they are for compatibility with older Python versions where these attributes may be `None`.', \\\"The `format_function_signature` function's logic for assembling the parameter string can be simplified. Instead of appending separators like `/` and `*` to a list and then filtering, the logic could build the final string more directly to improve readability.\\\", 'The broad `except Exception` in `ast_node_to_source` should be narrowed to catch more specific exceptions that `ast.unparse` might raise, preventing the accidental masking of unrelated errors.'],\\n    refactoring_summary='The primary goal of this refactoring is to enhance the maintainability and readability of the AST processing logic. This will be achieved by consolidating scattered helper functions into their primary calling contexts, reducing code duplication, and modernizing the syntax by leveraging structural pattern matching (`match...case`) for handling different AST node types. Additionally, the plan includes improving documentation for internal components and clarifying complex formatting logic to make the codebase easier to understand and extend.',\\n    plan_steps=['Consolidate the five internal parameter extraction helper functions (`_extract_positional_only_params`, `_extract_regular_params`, etc.) into the main `extract_parameters` generator. This will co-locate all signature parsing logic, eliminate redundant code, and improve readability by creating a single, sequential flow for parameter processing.', 'Refactor the `_FunctionVisitor.visit` method to replace the `isinstance` chain with a `match...case` statement (available in Python 3.10+). This will create a more readable and idiomatic dispatch mechanism for handling different AST node types like `ast.FunctionDef`, `ast.ClassDef`, and others.', 'Apply the same `match...case` modernization to the `parse_decorator` nested function within `extract_decorators` to more cleanly handle the different structures of decorator nodes (`ast.Name`, `ast.Call`).', 'Reduce code duplication between `parse_python_file` and `parse_python_source` by creating a single internal helper function that accepts an `ast.Module` object and a `module_name` string, and contains the common logic of creating the context and initiating the visitor.', 'Improve the clarity of the `format_function_signature` function by adding comments to explain the complex conditional logic for inserting the positional-only (`/`) and keyword-only (`*`) separators into the signature string.', \\\"Add class-level docstrings to internal helper classes, specifically `_FunctionVisitor`, to clearly document their purpose and responsibility within the module's architecture.\\\", 'In `_visit_function_def`, simplify the fallback values for `end_lineno` and `end_col_offset` by using the nullish coalescing operator (`or`) on a single line to improve conciseness, for example: `line_end=node.end_lineno or node.lineno`.'],\\n    refactored_code='```python\\\\nimport ast\\\\nimport enum\\\\nfrom dataclasses import dataclass\\\\nfrom pathlib import Path\\\\nfrom typing import Iterator, Type, Union\\\\n\\\\n\\\\nclass ParameterKind(enum.Enum):\\\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass Parameter:\\\\n    \\\"\\\"\\\"\\\\n    Represents a function parameter with its name, kind, and optional details.\\\\n\\\\n    Attributes:\\\\n        name: The name of the parameter.\\\\n        kind: The kind of the parameter (e.g., positional-only).\\\\n        annotation: The type annotation as a string, if present.\\\\n        default: The default value as a string, if present.\\\\n    \\\"\\\"\\\"\\\\n    name: str\\\\n    kind: ParameterKind\\\\n    annotation: str | None = None\\\\n    default: str | None = None\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass Decorator:\\\\n    \\\"\\\"\\\"\\\\n    Represents a function decorator.\\\\n\\\\n    Attributes:\\\\n        name: The name of the decorator.\\\\n        args: A tuple of arguments passed to the decorator, as strings.\\\\n    \\\"\\\"\\\"\\\\n    name: str\\\\n    args: tuple[str, ...] = ()\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass FunctionContext:\\\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\\\n    pass\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass ModuleContext(FunctionContext):\\\\n    \\\"\\\"\\\"\\\\n    Represents a function defined at the module level.\\\\n\\\\n    Attributes:\\\\n        module_name: The name of the module.\\\\n    \\\"\\\"\\\"\\\\n    module_name: str\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass ClassContext(FunctionContext):\\\\n    \\\"\\\"\\\"\\\\n    Represents a function defined within a class.\\\\n\\\\n    Attributes:\\\\n        class_name: The name of the class.\\\\n        parent_context: The context in which the class is defined.\\\\n    \\\"\\\"\\\"\\\\n    class_name: str\\\\n    parent_context: FunctionContext\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass NestedContext(FunctionContext):\\\\n    \\\"\\\"\\\"\\\\n    Represents a function defined within another function.\\\\n\\\\n    Attributes:\\\\n        parent_function: The name of the enclosing function.\\\\n        parent_context: The context of the enclosing function.\\\\n    \\\"\\\"\\\"\\\\n    parent_function: str\\\\n    parent_context: FunctionContext\\\\n\\\\n\\\\n@dataclass(frozen=True)\\\\nclass FunctionInfo:\\\\n    \\\"\\\"\\\"\\\\n    Stores complete metadata for a Python function.\\\\n\\\\n    Attributes:\\\\n        name: The name of the function.\\\\n        line_start: The starting line number of the function definition.\\\\n        line_end: The ending line number of the function definition.\\\\n        column_start: The starting column offset of the function definition.\\\\n        column_end: The ending column offset of the function definition.\\\\n        parameters: A tuple of Parameter objects for the function\\\\'s signature.\\\\n        decorators: A tuple of Decorator objects applied to the function.\\\\n        is_async: A boolean indicating if the function is asynchronous.\\\\n        context: The context (Module, Class, or Nested) where the function is defined.\\\\n        docstring: The function\\\\'s docstring, if present.\\\\n        return_annotation: The return type annotation as a string, if present.\\\\n    \\\"\\\"\\\"\\\\n    name: str\\\\n    line_start: int\\\\n    line_end: int\\\\n    column_start: int\\\\n    column_end: int\\\\n    parameters: tuple[Parameter, ...]\\\\n    decorators: tuple[Decorator, ...]\\\\n    is_async: bool\\\\n    context: FunctionContext\\\\n    docstring: str | None = None\\\\n    return_annotation: str | None = None\\\\n\\\\n\\\\ndef ast_node_to_source(node: ast.AST) -> str:\\\\n    \\\"\\\"\\\"\\\\n    Convert an AST node back to its source code representation.\\\\n\\\\n    Args:\\\\n        node: The AST node to convert.\\\\n\\\\n    Returns:\\\\n        The source code string for the node, or a repr for fallback.\\\\n    \\\"\\\"\\\"\\\\n    try:\\\\n        return ast.unparse(node)\\\\n    except Exception:\\\\n        return repr(node)\\\\n\\\\n\\\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\\\n    \\\"\\\"\\\"\\\\n    Extract decorator information from an AST decorator list.\\\\n\\\\n    Args:\\\\n        decorators: A list of decorator nodes from an AST function definition.\\\\n\\\\n    Returns:\\\\n        A tuple of Decorator objects.\\\\n    \\\"\\\"\\\"\\\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\\\n        match dec:\\\\n            case ast.Name(id=name):\\\\n                return Decorator(name=name)\\\\n            case ast.Call(func=ast.Name(id=name), args=args):\\\\n                return Decorator(\\\\n                    name=name,\\\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\\\n                )\\\\n            case ast.Call(func=func, args=args):\\\\n                return Decorator(\\\\n                    name=ast_node_to_source(func),\\\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\\\n                )\\\\n            case _:\\\\n                return Decorator(name=ast_node_to_source(dec))\\\\n\\\\n    return tuple(parse_decorator(dec) for dec in decorators)\\\\n\\\\n\\\\ndef extract_parameters(\\\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n) -> Iterator[Parameter]:\\\\n    \\\"\\\"\\\"\\\\n    Generate parameter information from a function\\\\'s AST node.\\\\n\\\\n    This function processes all parameter kinds in their correct order:\\\\n    positional-only, positional-or-keyword, var-positional (*args),\\\\n    keyword-only, and var-keyword (**kwargs).\\\\n\\\\n    Args:\\\\n        func_node: The function definition node from the AST.\\\\n\\\\n    Yields:\\\\n        Parameter objects representing the function\\\\'s signature.\\\\n    \\\"\\\"\\\"\\\\n    args = func_node.args\\\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\\\n    defaults_start_index = num_all_positional - len(args.defaults)\\\\n\\\\n    # 1. Positional-only parameters\\\\n    for i, arg in enumerate(args.posonlyargs):\\\\n        default = None\\\\n        if i >= defaults_start_index:\\\\n            default_index = i - defaults_start_index\\\\n            default = ast_node_to_source(args.defaults[default_index])\\\\n        yield Parameter(\\\\n            name=arg.arg,\\\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\\\n            default=default,\\\\n            kind=ParameterKind.POSITIONAL_ONLY,\\\\n        )\\\\n\\\\n    # 2. Positional-or-keyword parameters\\\\n    posonly_count = len(args.posonlyargs)\\\\n    for i, arg in enumerate(args.args):\\\\n        default = None\\\\n        combined_index = posonly_count + i\\\\n        if combined_index >= defaults_start_index:\\\\n            default_index = combined_index - defaults_start_index\\\\n            default = ast_node_to_source(args.defaults[default_index])\\\\n        yield Parameter(\\\\n            name=arg.arg,\\\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\\\n            default=default,\\\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\\\n        )\\\\n\\\\n    # 3. Variadic positional parameter (*args)\\\\n    if args.vararg:\\\\n        yield Parameter(\\\\n            name=args.vararg.arg,\\\\n            annotation=(\\\\n                ast_node_to_source(args.vararg.annotation)\\\\n                if args.vararg.annotation\\\\n                else None\\\\n            ),\\\\n            kind=ParameterKind.VAR_POSITIONAL,\\\\n        )\\\\n\\\\n    # 4. Keyword-only parameters\\\\n    for i, arg in enumerate(args.kwonlyargs):\\\\n        default_node = args.kw_defaults[i]\\\\n        yield Parameter(\\\\n            name=arg.arg,\\\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\\\n            default=ast_node_to_source(default_node) if default_node else None,\\\\n            kind=ParameterKind.KEYWORD_ONLY,\\\\n        )\\\\n\\\\n    # 5. Variadic keyword parameter (**kwargs)\\\\n    if args.kwarg:\\\\n        yield Parameter(\\\\n            name=args.kwarg.arg,\\\\n            annotation=(\\\\n                ast_node_to_source(args.kwarg.annotation)\\\\n                if args.kwarg.annotation\\\\n                else None\\\\n            ),\\\\n            kind=ParameterKind.VAR_KEYWORD,\\\\n        )\\\\n\\\\n\\\\ndef extract_docstring(\\\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n) -> str | None:\\\\n    \\\"\\\"\\\"\\\\n    Extract the docstring from a function node using ast.get_docstring.\\\\n\\\\n    Args:\\\\n        func_node: The function definition node from the AST.\\\\n\\\\n    Returns:\\\\n        The docstring string, or None if not found.\\\\n    \\\"\\\"\\\"\\\\n    return ast.get_docstring(func_node, clean=False)\\\\n\\\\n\\\\nclass _FunctionVisitor:\\\\n    \\\"\\\"\\\"\\\\n    An internal AST visitor to find and yield all function definitions.\\\\n\\\\n    This class traverses an AST, keeping track of the definition context\\\\n    (module, class, or nested function) and yields a `FunctionInfo`\\\\n    object for each function it encounters.\\\\n    \\\"\\\"\\\"\\\\n\\\\n    def visit(\\\\n        self, node: ast.AST, context: FunctionContext\\\\n    ) -> Iterator[FunctionInfo]:\\\\n        \\\"\\\"\\\"\\\\n        Recursively visit AST nodes and yield function information.\\\\n\\\\n        This method uses structural pattern matching to dispatch to more\\\\n        specific handlers based on the node type.\\\\n\\\\n        Args:\\\\n            node: The current AST node to visit.\\\\n            context: The current context (Module, Class, or Nested).\\\\n\\\\n        Yields:\\\\n            FunctionInfo objects for each function found.\\\\n        \\\"\\\"\\\"\\\\n        match node:\\\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\\\n                yield from self._visit_function_def(node, context)\\\\n            case ast.ClassDef():\\\\n                yield from self._visit_class_def(node, context)\\\\n            case _:\\\\n                for child in ast.iter_child_nodes(node):\\\\n                    yield from self.visit(child, context)\\\\n\\\\n    def _visit_function_def(\\\\n        self,\\\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\\\n        context: FunctionContext,\\\\n    ) -> Iterator[FunctionInfo]:\\\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\\\n        func_info = FunctionInfo(\\\\n            name=node.name,\\\\n            line_start=node.lineno,\\\\n            line_end=node.end_lineno or node.lineno,\\\\n            column_start=node.col_offset,\\\\n            column_end=node.end_col_offset or node.col_offset,\\\\n            parameters=tuple(extract_parameters(node)),\\\\n            decorators=extract_decorators(node.decorator_list),\\\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\\\n            context=context,\\\\n            docstring=extract_docstring(node),\\\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\\\n        )\\\\n        yield func_info\\\\n\\\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\\\n        for child in node.body:\\\\n            yield from self.visit(child, nested_context)\\\\n\\\\n    def _visit_class_def(\\\\n        self, node: ast.ClassDef, context: FunctionContext\\\\n    ) -> Iterator[FunctionInfo]:\\\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\\\n        for child in node.body:\\\\n            yield from self.visit(child, class_context)\\\\n\\\\n\\\\ndef _parse_ast_and_find_functions(\\\\n    tree: ast.Module, module_name: str\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Internal helper to process a parsed AST and yield function info.\\\\n\\\\n    Args:\\\\n        tree: The parsed AST module.\\\\n        module_name: The name of the module being parsed.\\\\n\\\\n    Yields:\\\\n        FunctionInfo objects for all functions in the AST.\\\\n    \\\"\\\"\\\"\\\\n    module_context = ModuleContext(module_name=module_name)\\\\n    visitor = _FunctionVisitor()\\\\n    yield from visitor.visit(tree, module_context)\\\\n\\\\n\\\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Parse a Python file and stream all function definitions.\\\\n\\\\n    Args:\\\\n        file_path: The path to the Python file.\\\\n\\\\n    Yields:\\\\n        FunctionInfo objects for all functions in the file.\\\\n    \\\"\\\"\\\"\\\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\\\n        source_code = f.read()\\\\n    tree = ast.parse(source_code, filename=str(file_path))\\\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\\\n\\\\n\\\\ndef parse_python_source(\\\\n    source_code: str, module_name: str = \\\"<string>\\\"\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Parse a Python source string and stream all function definitions.\\\\n\\\\n    Args:\\\\n        source_code: The Python code to parse.\\\\n        module_name: The name to associate with the module.\\\\n\\\\n    Yields:\\\\n        FunctionInfo objects for all functions in the code.\\\\n    \\\"\\\"\\\"\\\\n    tree = ast.parse(source_code, filename=module_name)\\\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\\\n\\\\n\\\\ndef filter_by_context(\\\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Filter functions by their context type (e.g., ClassContext).\\\\n\\\\n    Args:\\\\n        context_type: The context class to filter by (e.g., ClassContext).\\\\n        functions: An iterator of FunctionInfo objects to filter.\\\\n\\\\n    Yields:\\\\n        The functions that match the context type.\\\\n    \\\"\\\"\\\"\\\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\\\n\\\\n\\\\ndef filter_by_decorator(\\\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\\\n) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Filter functions that have a specific decorator.\\\\n\\\\n    Args:\\\\n        decorator_name: The name of the decorator to search for.\\\\n        functions: An iterator of FunctionInfo objects to filter.\\\\n\\\\n    Yields:\\\\n        The functions that have the specified decorator.\\\\n    \\\"\\\"\\\"\\\\n    yield from (\\\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\\\n    )\\\\n\\\\n\\\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\\\n    \\\"\\\"\\\"\\\\n    Extract just the names from a sequence of functions.\\\\n\\\\n    Args:\\\\n        functions: An iterator of FunctionInfo objects.\\\\n\\\\n    Yields:\\\\n        The function name strings.\\\\n    \\\"\\\"\\\"\\\\n    yield from (f.name for f in functions)\\\\n\\\\n\\\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Filter for and return only the asynchronous functions.\\\\n\\\\n    Args:\\\\n        functions: An iterator of FunctionInfo objects.\\\\n\\\\n    Yields:\\\\n        The async functions.\\\\n    \\\"\\\"\\\"\\\\n    yield from (f for f in functions if f.is_async)\\\\n\\\\n\\\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\\\n    \\\"\\\"\\\"\\\\n    Get all functions defined within a class context (methods).\\\\n\\\\n    Args:\\\\n        functions: An iterator of FunctionInfo objects.\\\\n\\\\n    Yields:\\\\n        The functions defined in a ClassContext.\\\\n    \\\"\\\"\\\"\\\\n    yield from filter_by_context(ClassContext, functions)\\\\n\\\\n\\\\ndef format_function_signature(func: FunctionInfo) -> str:\\\\n    \\\"\\\"\\\"\\\\n    Format a function\\\\'s signature into a human-readable string.\\\\n\\\\n    This function correctly handles positional-only, keyword-only, and\\\\n    variadic parameters.\\\\n\\\\n    Args:\\\\n        func: The FunctionInfo object to format.\\\\n\\\\n    Returns:\\\\n        A string representing the function\\\\'s signature.\\\\n    \\\"\\\"\\\"\\\\n    def format_param(p: Parameter) -> str:\\\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\\\n        res = p.name\\\\n        if p.annotation:\\\\n            res += f\\\": {p.annotation}\\\"\\\\n        if p.default is not None:\\\\n            res += f\\\" = {p.default}\\\"\\\\n        return res\\\\n\\\\n    parts = []\\\\n    pos_only = [\\\\n        format_param(p)\\\\n        for p in func.parameters\\\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\\\n    ]\\\\n    pos_or_kw = [\\\\n        format_param(p)\\\\n        for p in func.parameters\\\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\\\n    ]\\\\n    kw_only = [\\\\n        format_param(p)\\\\n        for p in func.parameters\\\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\\\n    ]\\\\n    var_pos = next(\\\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\\\n        None,\\\\n    )\\\\n    var_kw = next(\\\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\\\n        None,\\\\n    )\\\\n\\\\n    if pos_only:\\\\n        parts.append(\\\", \\\".join(pos_only))\\\\n        # Add the separator for positional-only arguments.\\\\n        parts.append(\\\"/\\\")\\\\n    if pos_or_kw:\\\\n        parts.append(\\\", \\\".join(pos_or_kw))\\\\n    if var_pos:\\\\n        parts.append(var_pos)\\\\n    # If there are keyword-only args but no *args, a bare \\\\'*\\\\' is needed.\\\\n    elif kw_only:\\\\n        parts.append(\\\"*\\\")\\\\n    if kw_only:\\\\n        parts.append(\\\", \\\".join(kw_only))\\\\n    if var_kw:\\\\n        parts.append(var_kw)\\\\n\\\\n    params_str = \\\", \\\".join(part for part in parts if part)\\\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\\\n```',\\n    implementation_explanation=\\\"The refactoring was executed according to the plan, resulting in a more maintainable and modern codebase.\\\\n\\\\n1.  **Consolidated Parameter Extraction:** The five internal `_extract_*_params` helper functions were successfully merged into the `extract_parameters` generator. This co-locates all parameter parsing logic, making the process a single, sequential flow that is easier to read and debug.\\\\n\\\\n2.  **Modernized AST Dispatching:** The `isinstance` chains in `_FunctionVisitor.visit` and `extract_decorators` were replaced with `match...case` statements. This structural pattern matching provides a more declarative and readable way to handle different AST node types, improving code clarity.\\\\n\\\\n3.  **Unified Parsing Logic:** Code duplication between `parse_python_file` and `parse_python_source` was eliminated by creating a new internal helper, `_parse_ast_and_find_functions`. This function centralizes the common logic of creating a `ModuleContext` and running the `_FunctionVisitor`, ensuring that both public-facing functions remain DRY.\\\\n\\\\n4.  **Improved Documentation and Clarity:** A class-level docstring was added to `_FunctionVisitor` to clarify its role as the core AST traversal engine. In `format_function_signature`, explanatory comments were added to demystify the conditional logic for inserting the `/` and `*` separators, enhancing the maintainability of the complex string formatting.\\\\n\\\\n5.  **Concise Fallbacks:** The concise `node.end_lineno or node.lineno` pattern for handling potentially missing `end_lineno` and `end_col_offset` attributes was verified and maintained, ensuring robustness without sacrificing readability.\\\\n\\\\nThese changes collectively enhance the code's structure, readability, and maintainability, aligning it with modern Python idioms and best practices.\\\"\\n)\"]}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "7fPKEyQVgUU=", "trace_state": "", "parent_span_id": "PABuF5vNfPQ=", "name": "Predict.forward_4", "start_time_unix_nano": 1750223797197295000, "end_time_unix_nano": 1750223813503994000, "attributes": {"mlflow.spanType": "\"LLM\"", "mlflow.spanOutputs": "{\"final_score\": 0.92, \"final_suggestion\": \"The code is functionally perfect, passing all tests. It is also very well-structured, with excellent complexity, typing, and docstring coverage. The only issue is the low linting score, which is caused exclusively by stylistic problems: lines exceeding the character limit and a missing newline at the end of the file. These can be easily and automatically fixed by running a code formatter like `black` or `autopep8`. Once formatted, this code is of excellent quality.\"}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "signature": "\"code_snippet, quality_scores, functional_score -> final_score, final_suggestion\"", "mlflow.spanInputs": "{\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"quality_scores\": \"{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9347826086956522,\\\"docstring_score\\\":0.9444444444444444,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:195:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:210:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:232:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:316:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:320:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:328:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:414:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:431:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:496:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:500:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:522:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:523:73: W292 no newline at end of file\\\"]}\", \"functional_score\": 1.0}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "ZNeA3xGD7VA=", "trace_state": "", "parent_span_id": "7fPKEyQVgUU=", "name": "ChatAdapter.format_4", "start_time_unix_nano": 1750223797197552000, "end_time_unix_nano": 1750223797198402000, "attributes": {"mlflow.spanOutputs": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The refactored code being evaluated.\\n2. `quality_scores` (str): A JSON object of quantitative scores (linting, complexity, typing, docstrings).\\n3. `functional_score` (float): A score from 0.0 to 1.0 indicating test pass rate.\\nYour output fields are:\\n1. `final_score` (float): A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.\\n2. `final_suggestion` (str): A final suggestion for improvement or a confirmation of readiness.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## quality_scores ## ]]\\n{quality_scores}\\n\\n[[ ## functional_score ## ]]\\n{functional_score}\\n\\n[[ ## final_score ## ]]\\n{final_score}        # note: the value you produce must be a single float value\\n\\n[[ ## final_suggestion ## ]]\\n{final_suggestion}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        Evaluate the refactored code based on quantitative scores and provide a final assessment.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## quality_scores ## ]]\\n{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9347826086956522,\\\"docstring_score\\\":0.9444444444444444,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:195:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:210:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:232:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:316:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:320:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:328:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:414:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:431:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:496:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:500:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:522:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:523:73: W292 no newline at end of file\\\"]}\\n\\n[[ ## functional_score ## ]]\\n1.0\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## final_score ## ]]` (must be formatted as a valid Python float), then `[[ ## final_suggestion ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}]", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"EvaluationSignature(code_snippet, quality_scores, functional_score -> final_score, final_suggestion\\n    instructions='Evaluate the refactored code based on quantitative scores and provide a final assessment.'\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The refactored code being evaluated.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    quality_scores = Field(annotation=str required=True json_schema_extra={'desc': 'A JSON object of quantitative scores (linting, complexity, typing, docstrings).', '__dspy_field_type': 'input', 'prefix': 'Quality Scores:'})\\n    functional_score = Field(annotation=float required=True json_schema_extra={'desc': 'A score from 0.0 to 1.0 indicating test pass rate.', '__dspy_field_type': 'input', 'prefix': 'Functional Score:'})\\n    final_score = Field(annotation=float required=True json_schema_extra={'desc': 'A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.', '__dspy_field_type': 'output', 'prefix': 'Final Score:'})\\n    final_suggestion = Field(annotation=str required=True json_schema_extra={'desc': 'A final suggestion for improvement or a confirmation of readiness.', '__dspy_field_type': 'output', 'prefix': 'Final Suggestion:'})\\n)\", \"demos\": [], \"inputs\": {\"code_snippet\": \"import ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\", \"quality_scores\": \"{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9347826086956522,\\\"docstring_score\\\":0.9444444444444444,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:195:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:210:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:232:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:316:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:320:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:328:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:414:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:431:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:496:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:500:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:522:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:523:73: W292 no newline at end of file\\\"]}\", \"functional_score\": 1.0}}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "+FLJdwhKLLw=", "trace_state": "", "parent_span_id": "7fPKEyQVgUU=", "name": "LM.__call___4", "start_time_unix_nano": 1750223797198475000, "end_time_unix_nano": 1750223813502372000, "attributes": {"model": "\"gemini/gemini-2.5-pro\"", "model_type": "\"chat\"", "temperature": "0.0", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "cache": "true", "mlflow.chat.messages": "[{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The refactored code being evaluated.\\n2. `quality_scores` (str): A JSON object of quantitative scores (linting, complexity, typing, docstrings).\\n3. `functional_score` (float): A score from 0.0 to 1.0 indicating test pass rate.\\nYour output fields are:\\n1. `final_score` (float): A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.\\n2. `final_suggestion` (str): A final suggestion for improvement or a confirmation of readiness.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## quality_scores ## ]]\\n{quality_scores}\\n\\n[[ ## functional_score ## ]]\\n{functional_score}\\n\\n[[ ## final_score ## ]]\\n{final_score}        # note: the value you produce must be a single float value\\n\\n[[ ## final_suggestion ## ]]\\n{final_suggestion}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        Evaluate the refactored code based on quantitative scores and provide a final assessment.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## quality_scores ## ]]\\n{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9347826086956522,\\\"docstring_score\\\":0.9444444444444444,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:195:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:210:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:232:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:316:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:320:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:328:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:414:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:431:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:496:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:500:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:522:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:523:73: W292 no newline at end of file\\\"]}\\n\\n[[ ## functional_score ## ]]\\n1.0\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## final_score ## ]]` (must be formatted as a valid Python float), then `[[ ## final_suggestion ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}, {\"role\": \"assistant\", \"content\": \"[[ ## final_score ## ]]\\n0.92\\n\\n[[ ## final_suggestion ## ]]\\nThe code is functionally perfect, passing all tests. It is also very well-structured, with excellent complexity, typing, and docstring coverage. The only issue is the low linting score, which is caused exclusively by stylistic problems: lines exceeding the character limit and a missing newline at the end of the file. These can be easily and automatically fixed by running a code formatter like `black` or `autopep8`. Once formatted, this code is of excellent quality.\\n\\n[[ ## completed ## ]]\"}]", "mlflow.spanOutputs": "[\"[[ ## final_score ## ]]\\n0.92\\n\\n[[ ## final_suggestion ## ]]\\nThe code is functionally perfect, passing all tests. It is also very well-structured, with excellent complexity, typing, and docstring coverage. The only issue is the low linting score, which is caused exclusively by stylistic problems: lines exceeding the character limit and a missing newline at the end of the file. These can be easily and automatically fixed by running a code formatter like `black` or `autopep8`. Once formatted, this code is of excellent quality.\\n\\n[[ ## completed ## ]]\"]", "mlflow.spanType": "\"CHAT_MODEL\"", "max_tokens": "64000", "mlflow.spanInputs": "{\"messages\": [{\"role\": \"system\", \"content\": \"Your input fields are:\\n1. `code_snippet` (str): The refactored code being evaluated.\\n2. `quality_scores` (str): A JSON object of quantitative scores (linting, complexity, typing, docstrings).\\n3. `functional_score` (float): A score from 0.0 to 1.0 indicating test pass rate.\\nYour output fields are:\\n1. `final_score` (float): A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.\\n2. `final_suggestion` (str): A final suggestion for improvement or a confirmation of readiness.\\nAll interactions will be structured in the following way, with the appropriate values filled in.\\n\\n[[ ## code_snippet ## ]]\\n{code_snippet}\\n\\n[[ ## quality_scores ## ]]\\n{quality_scores}\\n\\n[[ ## functional_score ## ]]\\n{functional_score}\\n\\n[[ ## final_score ## ]]\\n{final_score}        # note: the value you produce must be a single float value\\n\\n[[ ## final_suggestion ## ]]\\n{final_suggestion}\\n\\n[[ ## completed ## ]]\\nIn adhering to this structure, your objective is: \\n        Evaluate the refactored code based on quantitative scores and provide a final assessment.\"}, {\"role\": \"user\", \"content\": \"[[ ## code_snippet ## ]]\\nimport ast\\nimport enum\\nfrom dataclasses import dataclass\\nfrom pathlib import Path\\nfrom typing import Iterator, Type, Union\\n\\n\\nclass ParameterKind(enum.Enum):\\n    \\\"\\\"\\\"Enumeration for the different kinds of function parameters.\\\"\\\"\\\"\\n    POSITIONAL_ONLY = \\\"positional_only\\\"\\n    POSITIONAL_OR_KEYWORD = \\\"positional_or_keyword\\\"\\n    VAR_POSITIONAL = \\\"var_positional\\\"\\n    KEYWORD_ONLY = \\\"keyword_only\\\"\\n    VAR_KEYWORD = \\\"var_keyword\\\"\\n\\n\\n@dataclass(frozen=True)\\nclass Parameter:\\n    \\\"\\\"\\\"\\n    Represents a function parameter with its name, kind, and optional details.\\n\\n    Attributes:\\n        name: The name of the parameter.\\n        kind: The kind of the parameter (e.g., positional-only).\\n        annotation: The type annotation as a string, if present.\\n        default: The default value as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    kind: ParameterKind\\n    annotation: str | None = None\\n    default: str | None = None\\n\\n\\n@dataclass(frozen=True)\\nclass Decorator:\\n    \\\"\\\"\\\"\\n    Represents a function decorator.\\n\\n    Attributes:\\n        name: The name of the decorator.\\n        args: A tuple of arguments passed to the decorator, as strings.\\n    \\\"\\\"\\\"\\n    name: str\\n    args: tuple[str, ...] = ()\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionContext:\\n    \\\"\\\"\\\"Represents the context where a function is defined (base class).\\\"\\\"\\\"\\n    pass\\n\\n\\n@dataclass(frozen=True)\\nclass ModuleContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined at the module level.\\n\\n    Attributes:\\n        module_name: The name of the module.\\n    \\\"\\\"\\\"\\n    module_name: str\\n\\n\\n@dataclass(frozen=True)\\nclass ClassContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within a class.\\n\\n    Attributes:\\n        class_name: The name of the class.\\n        parent_context: The context in which the class is defined.\\n    \\\"\\\"\\\"\\n    class_name: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass NestedContext(FunctionContext):\\n    \\\"\\\"\\\"\\n    Represents a function defined within another function.\\n\\n    Attributes:\\n        parent_function: The name of the enclosing function.\\n        parent_context: The context of the enclosing function.\\n    \\\"\\\"\\\"\\n    parent_function: str\\n    parent_context: FunctionContext\\n\\n\\n@dataclass(frozen=True)\\nclass FunctionInfo:\\n    \\\"\\\"\\\"\\n    Stores complete metadata for a Python function.\\n\\n    Attributes:\\n        name: The name of the function.\\n        line_start: The starting line number of the function definition.\\n        line_end: The ending line number of the function definition.\\n        column_start: The starting column offset of the function definition.\\n        column_end: The ending column offset of the function definition.\\n        parameters: A tuple of Parameter objects for the function's signature.\\n        decorators: A tuple of Decorator objects applied to the function.\\n        is_async: A boolean indicating if the function is asynchronous.\\n        context: The context (Module, Class, or Nested) where the function is defined.\\n        docstring: The function's docstring, if present.\\n        return_annotation: The return type annotation as a string, if present.\\n    \\\"\\\"\\\"\\n    name: str\\n    line_start: int\\n    line_end: int\\n    column_start: int\\n    column_end: int\\n    parameters: tuple[Parameter, ...]\\n    decorators: tuple[Decorator, ...]\\n    is_async: bool\\n    context: FunctionContext\\n    docstring: str | None = None\\n    return_annotation: str | None = None\\n\\n\\ndef ast_node_to_source(node: ast.AST) -> str:\\n    \\\"\\\"\\\"\\n    Convert an AST node back to its source code representation.\\n\\n    Args:\\n        node: The AST node to convert.\\n\\n    Returns:\\n        The source code string for the node, or a repr for fallback.\\n    \\\"\\\"\\\"\\n    try:\\n        return ast.unparse(node)\\n    except Exception:\\n        return repr(node)\\n\\n\\ndef extract_decorators(decorators: list[ast.expr]) -> tuple[Decorator, ...]:\\n    \\\"\\\"\\\"\\n    Extract decorator information from an AST decorator list.\\n\\n    Args:\\n        decorators: A list of decorator nodes from an AST function definition.\\n\\n    Returns:\\n        A tuple of Decorator objects.\\n    \\\"\\\"\\\"\\n    def parse_decorator(dec: ast.expr) -> Decorator:\\n        match dec:\\n            case ast.Name(id=name):\\n                return Decorator(name=name)\\n            case ast.Call(func=ast.Name(id=name), args=args):\\n                return Decorator(\\n                    name=name,\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case ast.Call(func=func, args=args):\\n                return Decorator(\\n                    name=ast_node_to_source(func),\\n                    args=tuple(ast_node_to_source(arg) for arg in args)\\n                )\\n            case _:\\n                return Decorator(name=ast_node_to_source(dec))\\n\\n    return tuple(parse_decorator(dec) for dec in decorators)\\n\\n\\ndef extract_parameters(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> Iterator[Parameter]:\\n    \\\"\\\"\\\"\\n    Generate parameter information from a function's AST node.\\n\\n    This function processes all parameter kinds in their correct order:\\n    positional-only, positional-or-keyword, var-positional (*args),\\n    keyword-only, and var-keyword (**kwargs).\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Yields:\\n        Parameter objects representing the function's signature.\\n    \\\"\\\"\\\"\\n    args = func_node.args\\n    num_all_positional = len(args.posonlyargs) + len(args.args)\\n    defaults_start_index = num_all_positional - len(args.defaults)\\n\\n    # 1. Positional-only parameters\\n    for i, arg in enumerate(args.posonlyargs):\\n        default = None\\n        if i >= defaults_start_index:\\n            default_index = i - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_ONLY,\\n        )\\n\\n    # 2. Positional-or-keyword parameters\\n    posonly_count = len(args.posonlyargs)\\n    for i, arg in enumerate(args.args):\\n        default = None\\n        combined_index = posonly_count + i\\n        if combined_index >= defaults_start_index:\\n            default_index = combined_index - defaults_start_index\\n            default = ast_node_to_source(args.defaults[default_index])\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=default,\\n            kind=ParameterKind.POSITIONAL_OR_KEYWORD,\\n        )\\n\\n    # 3. Variadic positional parameter (*args)\\n    if args.vararg:\\n        yield Parameter(\\n            name=args.vararg.arg,\\n            annotation=(\\n                ast_node_to_source(args.vararg.annotation)\\n                if args.vararg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_POSITIONAL,\\n        )\\n\\n    # 4. Keyword-only parameters\\n    for i, arg in enumerate(args.kwonlyargs):\\n        default_node = args.kw_defaults[i]\\n        yield Parameter(\\n            name=arg.arg,\\n            annotation=ast_node_to_source(arg.annotation) if arg.annotation else None,\\n            default=ast_node_to_source(default_node) if default_node else None,\\n            kind=ParameterKind.KEYWORD_ONLY,\\n        )\\n\\n    # 5. Variadic keyword parameter (**kwargs)\\n    if args.kwarg:\\n        yield Parameter(\\n            name=args.kwarg.arg,\\n            annotation=(\\n                ast_node_to_source(args.kwarg.annotation)\\n                if args.kwarg.annotation\\n                else None\\n            ),\\n            kind=ParameterKind.VAR_KEYWORD,\\n        )\\n\\n\\ndef extract_docstring(\\n    func_node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n) -> str | None:\\n    \\\"\\\"\\\"\\n    Extract the docstring from a function node using ast.get_docstring.\\n\\n    Args:\\n        func_node: The function definition node from the AST.\\n\\n    Returns:\\n        The docstring string, or None if not found.\\n    \\\"\\\"\\\"\\n    return ast.get_docstring(func_node, clean=False)\\n\\n\\nclass _FunctionVisitor:\\n    \\\"\\\"\\\"\\n    An internal AST visitor to find and yield all function definitions.\\n\\n    This class traverses an AST, keeping track of the definition context\\n    (module, class, or nested function) and yields a `FunctionInfo`\\n    object for each function it encounters.\\n    \\\"\\\"\\\"\\n\\n    def visit(\\n        self, node: ast.AST, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"\\n        Recursively visit AST nodes and yield function information.\\n\\n        This method uses structural pattern matching to dispatch to more\\n        specific handlers based on the node type.\\n\\n        Args:\\n            node: The current AST node to visit.\\n            context: The current context (Module, Class, or Nested).\\n\\n        Yields:\\n            FunctionInfo objects for each function found.\\n        \\\"\\\"\\\"\\n        match node:\\n            case ast.FunctionDef() | ast.AsyncFunctionDef():\\n                yield from self._visit_function_def(node, context)\\n            case ast.ClassDef():\\n                yield from self._visit_class_def(node, context)\\n            case _:\\n                for child in ast.iter_child_nodes(node):\\n                    yield from self.visit(child, context)\\n\\n    def _visit_function_def(\\n        self,\\n        node: Union[ast.FunctionDef, ast.AsyncFunctionDef],\\n        context: FunctionContext,\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle FunctionDef and AsyncFunctionDef nodes.\\\"\\\"\\\"\\n        func_info = FunctionInfo(\\n            name=node.name,\\n            line_start=node.lineno,\\n            line_end=node.end_lineno or node.lineno,\\n            column_start=node.col_offset,\\n            column_end=node.end_col_offset or node.col_offset,\\n            parameters=tuple(extract_parameters(node)),\\n            decorators=extract_decorators(node.decorator_list),\\n            is_async=isinstance(node, ast.AsyncFunctionDef),\\n            context=context,\\n            docstring=extract_docstring(node),\\n            return_annotation=ast_node_to_source(node.returns) if node.returns else None,\\n        )\\n        yield func_info\\n\\n        nested_context = NestedContext(parent_function=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, nested_context)\\n\\n    def _visit_class_def(\\n        self, node: ast.ClassDef, context: FunctionContext\\n    ) -> Iterator[FunctionInfo]:\\n        \\\"\\\"\\\"Handle ClassDef nodes.\\\"\\\"\\\"\\n        class_context = ClassContext(class_name=node.name, parent_context=context)\\n        for child in node.body:\\n            yield from self.visit(child, class_context)\\n\\n\\ndef _parse_ast_and_find_functions(\\n    tree: ast.Module, module_name: str\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Internal helper to process a parsed AST and yield function info.\\n\\n    Args:\\n        tree: The parsed AST module.\\n        module_name: The name of the module being parsed.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the AST.\\n    \\\"\\\"\\\"\\n    module_context = ModuleContext(module_name=module_name)\\n    visitor = _FunctionVisitor()\\n    yield from visitor.visit(tree, module_context)\\n\\n\\ndef parse_python_file(file_path: Path) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python file and stream all function definitions.\\n\\n    Args:\\n        file_path: The path to the Python file.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the file.\\n    \\\"\\\"\\\"\\n    with open(file_path, \\\"r\\\", encoding=\\\"utf-8\\\") as f:\\n        source_code = f.read()\\n    tree = ast.parse(source_code, filename=str(file_path))\\n    yield from _parse_ast_and_find_functions(tree, file_path.stem)\\n\\n\\ndef parse_python_source(\\n    source_code: str, module_name: str = \\\"<string>\\\"\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Parse a Python source string and stream all function definitions.\\n\\n    Args:\\n        source_code: The Python code to parse.\\n        module_name: The name to associate with the module.\\n\\n    Yields:\\n        FunctionInfo objects for all functions in the code.\\n    \\\"\\\"\\\"\\n    tree = ast.parse(source_code, filename=module_name)\\n    yield from _parse_ast_and_find_functions(tree, module_name)\\n\\n\\ndef filter_by_context(\\n    context_type: Type[FunctionContext], functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions by their context type (e.g., ClassContext).\\n\\n    Args:\\n        context_type: The context class to filter by (e.g., ClassContext).\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that match the context type.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if isinstance(f.context, context_type))\\n\\n\\ndef filter_by_decorator(\\n    decorator_name: str, functions: Iterator[FunctionInfo]\\n) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter functions that have a specific decorator.\\n\\n    Args:\\n        decorator_name: The name of the decorator to search for.\\n        functions: An iterator of FunctionInfo objects to filter.\\n\\n    Yields:\\n        The functions that have the specified decorator.\\n    \\\"\\\"\\\"\\n    yield from (\\n        f for f in functions if any(d.name == decorator_name for d in f.decorators)\\n    )\\n\\n\\ndef get_function_names(functions: Iterator[FunctionInfo]) -> Iterator[str]:\\n    \\\"\\\"\\\"\\n    Extract just the names from a sequence of functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The function name strings.\\n    \\\"\\\"\\\"\\n    yield from (f.name for f in functions)\\n\\n\\ndef get_async_functions(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Filter for and return only the asynchronous functions.\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The async functions.\\n    \\\"\\\"\\\"\\n    yield from (f for f in functions if f.is_async)\\n\\n\\ndef get_methods(functions: Iterator[FunctionInfo]) -> Iterator[FunctionInfo]:\\n    \\\"\\\"\\\"\\n    Get all functions defined within a class context (methods).\\n\\n    Args:\\n        functions: An iterator of FunctionInfo objects.\\n\\n    Yields:\\n        The functions defined in a ClassContext.\\n    \\\"\\\"\\\"\\n    yield from filter_by_context(ClassContext, functions)\\n\\n\\ndef format_function_signature(func: FunctionInfo) -> str:\\n    \\\"\\\"\\\"\\n    Format a function's signature into a human-readable string.\\n\\n    This function correctly handles positional-only, keyword-only, and\\n    variadic parameters.\\n\\n    Args:\\n        func: The FunctionInfo object to format.\\n\\n    Returns:\\n        A string representing the function's signature.\\n    \\\"\\\"\\\"\\n    def format_param(p: Parameter) -> str:\\n        \\\"\\\"\\\"Formats a single parameter object into a string.\\\"\\\"\\\"\\n        res = p.name\\n        if p.annotation:\\n            res += f\\\": {p.annotation}\\\"\\n        if p.default is not None:\\n            res += f\\\" = {p.default}\\\"\\n        return res\\n\\n    parts = []\\n    pos_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_ONLY\\n    ]\\n    pos_or_kw = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.POSITIONAL_OR_KEYWORD\\n    ]\\n    kw_only = [\\n        format_param(p)\\n        for p in func.parameters\\n        if p.kind == ParameterKind.KEYWORD_ONLY\\n    ]\\n    var_pos = next(\\n        (f\\\"*{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_POSITIONAL),\\n        None,\\n    )\\n    var_kw = next(\\n        (f\\\"**{p.name}\\\" for p in func.parameters if p.kind == ParameterKind.VAR_KEYWORD),\\n        None,\\n    )\\n\\n    if pos_only:\\n        parts.append(\\\", \\\".join(pos_only))\\n        # Add the separator for positional-only arguments.\\n        parts.append(\\\"/\\\")\\n    if pos_or_kw:\\n        parts.append(\\\", \\\".join(pos_or_kw))\\n    if var_pos:\\n        parts.append(var_pos)\\n    # If there are keyword-only args but no *args, a bare '*' is needed.\\n    elif kw_only:\\n        parts.append(\\\"*\\\")\\n    if kw_only:\\n        parts.append(\\\", \\\".join(kw_only))\\n    if var_kw:\\n        parts.append(var_kw)\\n\\n    params_str = \\\", \\\".join(part for part in parts if part)\\n    async_prefix = \\\"async \\\" if func.is_async else \\\"\\\"\\n    return_suffix = f\\\" -> {func.return_annotation}\\\" if func.return_annotation else \\\"\\\"\\n    return f\\\"{async_prefix}def {func.name}({params_str}){return_suffix}\\\"\\n\\n[[ ## quality_scores ## ]]\\n{\\\"linting_score\\\":0.0,\\\"complexity_score\\\":1.0,\\\"typing_score\\\":0.9347826086956522,\\\"docstring_score\\\":0.9444444444444444,\\\"linting_issues\\\":[\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:104:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:195:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:210:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:232:80: E501 line too long (86 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:316:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:320:80: E501 line too long (89 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:328:80: E501 line too long (82 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:414:80: E501 line too long (83 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:431:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:496:80: E501 line too long (90 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:500:80: E501 line too long (88 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:522:80: E501 line too long (85 > 79 characters)\\\",\\\"/var/folders/5z/t9071jp52r717yyzh_09txmm0000gn/T/tmpocmeowyw.py:523:73: W292 no newline at end of file\\\"]}\\n\\n[[ ## functional_score ## ]]\\n1.0\\n\\nRespond with the corresponding output fields, starting with the field `[[ ## final_score ## ]]` (must be formatted as a valid Python float), then `[[ ## final_suggestion ## ]]`, and then ending with the marker for `[[ ## completed ## ]]`.\"}], \"prompt\": null}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}, {"trace_id": "IIKxy9JzhFyULDU0EGPGRg==", "span_id": "QUUgJRP01r4=", "trace_state": "", "parent_span_id": "7fPKEyQVgUU=", "name": "ChatAdapter.parse_4", "start_time_unix_nano": 1750223813502716000, "end_time_unix_nano": 1750223813503851000, "attributes": {"mlflow.spanOutputs": "{\"final_score\": 0.92, \"final_suggestion\": \"The code is functionally perfect, passing all tests. It is also very well-structured, with excellent complexity, typing, and docstring coverage. The only issue is the low linting score, which is caused exclusively by stylistic problems: lines exceeding the character limit and a missing newline at the end of the file. These can be easily and automatically fixed by running a code formatter like `black` or `autopep8`. Once formatted, this code is of excellent quality.\"}", "mlflow.traceRequestId": "\"3f45e04843e847f7b109c81e3e7b067c\"", "mlflow.spanType": "\"PARSER\"", "mlflow.spanInputs": "{\"signature\": \"EvaluationSignature(code_snippet, quality_scores, functional_score -> final_score, final_suggestion\\n    instructions='Evaluate the refactored code based on quantitative scores and provide a final assessment.'\\n    code_snippet = Field(annotation=str required=True json_schema_extra={'desc': 'The refactored code being evaluated.', '__dspy_field_type': 'input', 'prefix': 'Code Snippet:'})\\n    quality_scores = Field(annotation=str required=True json_schema_extra={'desc': 'A JSON object of quantitative scores (linting, complexity, typing, docstrings).', '__dspy_field_type': 'input', 'prefix': 'Quality Scores:'})\\n    functional_score = Field(annotation=float required=True json_schema_extra={'desc': 'A score from 0.0 to 1.0 indicating test pass rate.', '__dspy_field_type': 'input', 'prefix': 'Functional Score:'})\\n    final_score = Field(annotation=float required=True json_schema_extra={'desc': 'A final, holistic score from 0.0 to 1.0, weighting functional correctness most heavily.', '__dspy_field_type': 'output', 'prefix': 'Final Score:'})\\n    final_suggestion = Field(annotation=str required=True json_schema_extra={'desc': 'A final suggestion for improvement or a confirmation of readiness.', '__dspy_field_type': 'output', 'prefix': 'Final Suggestion:'})\\n)\", \"completion\": \"[[ ## final_score ## ]]\\n0.92\\n\\n[[ ## final_suggestion ## ]]\\nThe code is functionally perfect, passing all tests. It is also very well-structured, with excellent complexity, typing, and docstring coverage. The only issue is the low linting score, which is caused exclusively by stylistic problems: lines exceeding the character limit and a missing newline at the end of the file. These can be easily and automatically fixed by running a code formatter like `black` or `autopep8`. Once formatted, this code is of excellent quality.\\n\\n[[ ## completed ## ]]\"}"}, "status": {"message": "", "code": "STATUS_CODE_OK"}}]}